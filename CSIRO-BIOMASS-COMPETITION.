{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "dce4597f",
   "metadata": {
    "_cell_guid": "5061a83f-9d83-4302-9d3a-659adc5273a7",
    "_uuid": "51e1b95a-cf50-4259-906b-fbf334258d3d",
    "collapsed": false,
    "execution": {
     "iopub.execute_input": "2025-12-27T04:03:26.087476Z",
     "iopub.status.busy": "2025-12-27T04:03:26.086936Z",
     "iopub.status.idle": "2025-12-27T04:03:27.284037Z",
     "shell.execute_reply": "2025-12-27T04:03:27.283282Z"
    },
    "jupyter": {
     "outputs_hidden": false
    },
    "papermill": {
     "duration": 1.20504,
     "end_time": "2025-12-27T04:03:27.286272",
     "exception": false,
     "start_time": "2025-12-27T04:03:26.081232",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "/kaggle/input/google-siglip-so400m-patch14-384/transformers/default/1/config.json\n",
      "/kaggle/input/google-siglip-so400m-patch14-384/transformers/default/1/preprocessor_config.json\n",
      "/kaggle/input/google-siglip-so400m-patch14-384/transformers/default/1/spiece.model\n",
      "/kaggle/input/google-siglip-so400m-patch14-384/transformers/default/1/README.md\n",
      "/kaggle/input/google-siglip-so400m-patch14-384/transformers/default/1/tokenizer.json\n",
      "/kaggle/input/google-siglip-so400m-patch14-384/transformers/default/1/tokenizer_config.json\n",
      "/kaggle/input/google-siglip-so400m-patch14-384/transformers/default/1/gitattributes\n",
      "/kaggle/input/google-siglip-so400m-patch14-384/transformers/default/1/model.safetensors\n",
      "/kaggle/input/google-siglip-so400m-patch14-384/transformers/default/1/special_tokens_map.json\n",
      "/kaggle/input/csiro-biomass-competition-comprehensive-eda/__results__.html\n",
      "/kaggle/input/csiro-biomass-competition-comprehensive-eda/__notebook__.ipynb\n",
      "/kaggle/input/csiro-biomass-competition-comprehensive-eda/__output__.json\n",
      "/kaggle/input/csiro-biomass-competition-comprehensive-eda/custom.css\n",
      "/kaggle/input/csiro-biomass-competition-comprehensive-eda/__results___files/__results___15_0.png\n",
      "/kaggle/input/csiro-biomass-competition-comprehensive-eda/__results___files/__results___25_0.png\n",
      "/kaggle/input/csiro-biomass-competition-comprehensive-eda/__results___files/__results___19_0.png\n",
      "/kaggle/input/csiro-biomass-competition-comprehensive-eda/__results___files/__results___31_0.png\n",
      "/kaggle/input/csiro-biomass-competition-comprehensive-eda/__results___files/__results___22_0.png\n",
      "/kaggle/input/csiro-biomass-competition-comprehensive-eda/__results___files/__results___28_0.png\n",
      "/kaggle/input/csiro-image-embeddings/train_siglip_embeddings.csv\n",
      "/kaggle/input/csiro-image-embeddings/train_dino_embeddings.csv\n",
      "/kaggle/input/csiro-mvp-models/model1.pth\n",
      "/kaggle/input/csiro-mvp-models/model2.pth\n",
      "/kaggle/input/csiro-mvp-models/model10.pth\n",
      "/kaggle/input/csiro-mvp-models/model7.pth\n",
      "/kaggle/input/csiro-mvp-models/model6.pth\n",
      "/kaggle/input/csiro-mvp-models/model4.pth\n",
      "/kaggle/input/csiro-mvp-models/model5.pth\n",
      "/kaggle/input/csiro-mvp-models/model9.pth\n",
      "/kaggle/input/csiro-mvp-models/model3.pth\n",
      "/kaggle/input/csiro-mvp-models/model8.pth\n",
      "/kaggle/input/csiro-biomass/sample_submission.csv\n",
      "/kaggle/input/csiro-biomass/train.csv\n",
      "/kaggle/input/csiro-biomass/test.csv\n",
      "/kaggle/input/csiro-biomass/test/ID1001187975.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID2099464826.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID2037861084.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1211362607.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1853508321.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID193102215.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID698608346.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1859251563.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1880764911.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID853954911.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1403107574.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1781353117.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID384648061.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1563418511.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID2125100696.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID482555369.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID638711343.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID779628955.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1876271942.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1692894460.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID746335827.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1136169672.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1471216911.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID846154859.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1294770420.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1183807388.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID423506847.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1889150649.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1140993511.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1413758094.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1545077474.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID95050718.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID528010569.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1645161155.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID786365141.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID896386823.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1025234388.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID663006174.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1509266870.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1496750796.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID471758347.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID740402124.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1624268863.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1098771283.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID710341728.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID2086966681.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1573329652.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID54128926.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID50027657.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1559189397.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID290369222.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1590632667.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID552040066.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID488873801.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID363069566.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1839139621.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1131079710.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID2010625680.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID152157478.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1357758282.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1498398599.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID679913293.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID697718693.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID4464212.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1275072698.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1579942839.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID799079114.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1415329644.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1510574031.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1078930021.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1456861072.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID930534670.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID13162390.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID567744300.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID344618040.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID566966892.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1437386574.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID667059550.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID72895391.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1193692654.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1386202352.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID871463897.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID2096636211.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID2003438517.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID21377800.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID230058600.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1753847361.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1512751450.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID12390962.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1746343319.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID978026131.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID383231615.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID146920896.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1036339023.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1168534540.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1859792585.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1251029854.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1113329413.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1874904894.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1671844336.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1831254380.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1103883611.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID797502182.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1784585001.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1058383417.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1488408526.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID429799190.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1291116815.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1516374298.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1618597318.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1345375788.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID686797154.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1139866256.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1149598723.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID212206250.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID112966473.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1540480250.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID544444725.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1513184765.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID668330410.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1444674500.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1962379474.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID605134229.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID914754166.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID354528442.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID950496197.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1395011773.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1357768767.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID210865340.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID936984905.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1976436386.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1215977190.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID803479541.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1244346858.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID158170916.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1208644039.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1314135397.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1012260530.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1053972079.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID656251220.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1084819986.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1337107565.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1268934251.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID617132135.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1472525822.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID668475812.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID681680726.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1476045099.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1570190541.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1403078396.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID2030696575.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1782608354.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID194823383.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID196516535.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID212206832.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1638922597.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1457700382.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1989506559.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID789169173.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1634731537.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1428837636.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID2006686196.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID885388135.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1789853061.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1655778545.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID697059386.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID121331988.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID2099742797.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID342818398.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID317990700.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID706288721.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1159071020.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID755710743.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1254829053.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID475010202.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1693880739.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1894998379.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID48303557.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1385921939.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID147528735.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID407646960.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1035947949.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1119761112.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1988033238.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1857489997.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID742198710.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID588120964.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID431471530.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID353424190.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID380752847.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID2069766023.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID600602588.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID560946727.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1011485656.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID808079729.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1217108125.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1623964968.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID980878870.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID793526563.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID397994621.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID975115267.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1237349078.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID684383343.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID866684633.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1665142816.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID2048645043.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1953171547.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1451025862.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID71885430.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID307060225.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID969218269.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID980538882.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1028611175.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID670276799.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID2002797732.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1374789439.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID473494649.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1993907137.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1962197151.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID828217731.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID972274220.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1954669045.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1354190372.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1458758610.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID40849327.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1952813879.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID572336285.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1473228876.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1963715583.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1463690813.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1899025384.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID386216505.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1789265307.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID315357834.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID2089023774.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID520514019.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1970522802.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1139918758.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1051144034.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1370004842.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID761508093.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID2052993274.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1277756619.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID6269659.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1574125908.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID135365668.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1182523622.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID554314721.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1049634115.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1127246618.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID900012207.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID574213894.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID415656958.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID61833032.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID2053315094.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID550623196.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID657448172.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1675365449.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID2014192906.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID162394992.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID968643034.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID684062938.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID802547515.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID294150104.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1618145129.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID956512130.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID142751858.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID325799913.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID443091455.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID661372352.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1062837331.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID498304885.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID187238869.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1450399782.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID2056023629.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID576621307.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1199150612.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1411613934.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID105271783.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1703304524.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID875119737.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1176292407.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1729002155.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID2091439402.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID576137678.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1946311744.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1982662138.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID983582017.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID661817669.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID753699705.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1789834546.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID529933668.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID490139972.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID743847993.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID7850481.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1088965591.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID629980789.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1119739385.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1477176296.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1113121340.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID2131261930.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID2145635095.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1414371018.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1148666289.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID839432753.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID157479394.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1761544403.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID846984946.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID751517087.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID577112774.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID353997899.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID748979397.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1070112260.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1108283583.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1868719645.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1980675327.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1163061745.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1148528732.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID534966093.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1717006117.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1953218650.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID633775166.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID808093827.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1997244125.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1920959057.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1948354837.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID364856705.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID249042826.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID332742639.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1680597197.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1421714468.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID905397692.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1782509721.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID141370843.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID2056982009.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID94564238.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID8209776.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID908524512.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID610397481.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID750820644.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1515990019.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1547945326.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID587125778.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1620371305.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1474775613.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID545360459.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1783499590.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1249094008.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1525817840.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID227847873.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1052620238.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1888700589.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID2052442675.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID963903358.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1121692672.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1343327476.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID1667778338.jpg\n",
      "/kaggle/input/csiro-biomass/train/ID257822026.jpg\n",
      "/kaggle/input/csiro/pytorch/default/12/fold_0/metrics.csv\n",
      "/kaggle/input/csiro/pytorch/default/12/fold_0/swanlab_info.json\n",
      "/kaggle/input/csiro/pytorch/default/12/fold_0/checkpoints/best_loss.pt\n",
      "/kaggle/input/csiro/pytorch/default/12/fold_0/checkpoints/best_wr2.pt\n",
      "/kaggle/input/csiro/pytorch/default/12/fold_0/checkpoints/last.pt\n",
      "/kaggle/input/csiro/pytorch/default/12/fold_4/metrics.csv\n",
      "/kaggle/input/csiro/pytorch/default/12/fold_4/swanlab_info.json\n",
      "/kaggle/input/csiro/pytorch/default/12/fold_4/checkpoints/best_loss.pt\n",
      "/kaggle/input/csiro/pytorch/default/12/fold_4/checkpoints/best_wr2.pt\n",
      "/kaggle/input/csiro/pytorch/default/12/fold_4/checkpoints/last.pt\n",
      "/kaggle/input/csiro/pytorch/default/12/fold_1/metrics.csv\n",
      "/kaggle/input/csiro/pytorch/default/12/fold_1/swanlab_info.json\n",
      "/kaggle/input/csiro/pytorch/default/12/fold_1/checkpoints/best_loss.pt\n",
      "/kaggle/input/csiro/pytorch/default/12/fold_1/checkpoints/best_wr2.pt\n",
      "/kaggle/input/csiro/pytorch/default/12/fold_1/checkpoints/last.pt\n",
      "/kaggle/input/csiro/pytorch/default/12/fold_3/metrics.csv\n",
      "/kaggle/input/csiro/pytorch/default/12/fold_3/swanlab_info.json\n",
      "/kaggle/input/csiro/pytorch/default/12/fold_3/checkpoints/best_loss.pt\n",
      "/kaggle/input/csiro/pytorch/default/12/fold_3/checkpoints/best_wr2.pt\n",
      "/kaggle/input/csiro/pytorch/default/12/fold_3/checkpoints/last.pt\n",
      "/kaggle/input/csiro/pytorch/default/12/fold_2/metrics.csv\n",
      "/kaggle/input/csiro/pytorch/default/12/fold_2/swanlab_info.json\n",
      "/kaggle/input/csiro/pytorch/default/12/fold_2/checkpoints/best_loss.pt\n",
      "/kaggle/input/csiro/pytorch/default/12/fold_2/checkpoints/best_wr2.pt\n",
      "/kaggle/input/csiro/pytorch/default/12/fold_2/checkpoints/last.pt\n",
      "/kaggle/input/csiro-datasplit/__results__.html\n",
      "/kaggle/input/csiro-datasplit/csiro_data_split.csv\n",
      "/kaggle/input/csiro-datasplit/__notebook__.ipynb\n",
      "/kaggle/input/csiro-datasplit/__output__.json\n",
      "/kaggle/input/csiro-datasplit/custom.css\n",
      "/kaggle/input/dinov2/pytorch/giant/1/config.json\n",
      "/kaggle/input/dinov2/pytorch/giant/1/preprocessor_config.json\n",
      "/kaggle/input/dinov2/pytorch/giant/1/README.md\n",
      "/kaggle/input/dinov2/pytorch/giant/1/pytorch_model.bin\n",
      "/kaggle/input/dinov2/pytorch/giant/1/.gitattributes\n"
     ]
    }
   ],
   "source": [
    "# This Python 3 environment comes with many helpful analytics libraries installed\n",
    "# It is defined by the kaggle/python Docker image: https://github.com/kaggle/docker-python\n",
    "# For example, here's several helpful packages to load\n",
    "\n",
    "import numpy as np # linear algebra\n",
    "import pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)\n",
    "\n",
    "# Input data files are available in the read-only \"../input/\" directory\n",
    "# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n",
    "\n",
    "import os\n",
    "for dirname, _, filenames in os.walk('/kaggle/input'):\n",
    "    for filename in filenames:\n",
    "        print(os.path.join(dirname, filename))\n",
    "\n",
    "# You can write up to 20GB to the current directory (/kaggle/working/) that gets preserved as output when you create a version using \"Save & Run All\" \n",
    "# You can also write temporary files to /kaggle/temp/, but they won't be saved outside of the current session"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "68db87e5",
   "metadata": {
    "_cell_guid": "9a182e42-6a25-4449-b40b-efcfd297fe51",
    "_uuid": "eba9ea1a-132a-4d3b-b627-956bdfcf899c",
    "collapsed": false,
    "execution": {
     "iopub.execute_input": "2025-12-27T04:03:27.295231Z",
     "iopub.status.busy": "2025-12-27T04:03:27.294876Z",
     "iopub.status.idle": "2025-12-27T04:03:52.661914Z",
     "shell.execute_reply": "2025-12-27T04:03:52.661109Z"
    },
    "jupyter": {
     "outputs_hidden": false
    },
    "papermill": {
     "duration": 25.373531,
     "end_time": "2025-12-27T04:03:52.663831",
     "exception": false,
     "start_time": "2025-12-27T04:03:27.290300",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "================================================================================\n",
      "CSIRO BIOMASS COMPETITION - PROFESSIONAL EDA\n",
      "================================================================================\n",
      "\n",
      "Loading data...\n",
      "Train shape: (1785, 9)\n",
      "Test shape: (5, 3)\n",
      "Pivoted train shape: (357, 6)\n",
      "\n",
      "================================================================================\n",
      "Creating Visualization 1: Target Distributions with Normal Curves\n",
      "================================================================================\n",
      "✓ Saved: professional_1_distributions.png\n",
      "\n",
      "================================================================================\n",
      "Creating Visualization 2: Complete Correlation Matrix\n",
      "================================================================================\n",
      "✓ Saved: professional_2_correlation_matrix.png\n",
      "\n",
      "================================================================================\n",
      "Creating Visualization 3: Detailed Box Plots\n",
      "================================================================================\n",
      "✓ Saved: professional_3_boxplots.png\n",
      "\n",
      "================================================================================\n",
      "Creating Visualization 4: Scatter Plot Matrix\n",
      "================================================================================\n",
      "✓ Saved: professional_4_scatter_matrix.png\n",
      "\n",
      "================================================================================\n",
      "Creating Visualization 5: Detailed Sample Image Analysis\n",
      "================================================================================\n",
      "✓ Saved: professional_5_sample_images.png\n",
      "\n",
      "================================================================================\n",
      "Creating Visualization 6: Hierarchical Relationships\n",
      "================================================================================\n",
      "✓ Saved: professional_6_hierarchical.png\n",
      "\n",
      "================================================================================\n",
      "EDA COMPLETE - ALL VISUALIZATIONS SAVED\n",
      "================================================================================\n",
      "\n",
      "Generated Professional Visualizations:\n",
      "  1. professional_1_distributions.png - Target distributions with bell curves\n",
      "  2. professional_2_correlation_matrix.png - Complete correlation analysis\n",
      "  3. professional_3_boxplots.png - Detailed box plots with statistics\n",
      "  4. professional_4_scatter_matrix.png - Scatter plot matrix with regression\n",
      "  5. professional_5_sample_images.png - Detailed image analysis\n",
      "  6. professional_6_hierarchical.png - Hierarchical relationship validation\n",
      "\n",
      "All visualizations use consistent professional color scheme\n",
      "Statistical details and annotations included on all plots\n",
      "================================================================================\n"
     ]
    }
   ],
   "source": [
    "# ================================================================\n",
    "# CSIRO BIOMASS COMPETITION - PROFESSIONAL EDA\n",
    "# ================================================================\n",
    "# Professional visualizations with consistent color scheme\n",
    "# Complete statistical analysis with bell curves and annotations\n",
    "# ================================================================\n",
    "\n",
    "import os\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "import cv2\n",
    "from PIL import Image\n",
    "from pathlib import Path\n",
    "from tqdm.auto import tqdm\n",
    "import warnings\n",
    "warnings.filterwarnings('ignore')\n",
    "\n",
    "from scipy import stats\n",
    "from scipy.stats import skew, kurtosis, normaltest, pearsonr, spearmanr, norm\n",
    "from sklearn.preprocessing import StandardScaler\n",
    "from sklearn.decomposition import PCA\n",
    "\n",
    "# ================================================================\n",
    "# PROFESSIONAL STYLING CONFIGURATION\n",
    "# ================================================================\n",
    "\n",
    "# Professional color palette (consistent across all plots)\n",
    "COLORS = {\n",
    "    'primary': '#2E4057',      # Dark blue-gray (main)\n",
    "    'secondary': '#048A81',     # Teal (accent)\n",
    "    'tertiary': '#54C6EB',      # Light blue\n",
    "    'highlight': '#D95D39',     # Coral red (emphasis)\n",
    "    'neutral': '#8B8B8B',       # Gray\n",
    "    'background': '#F5F5F5',    # Light gray background\n",
    "    'grid': '#E0E0E0',          # Grid color\n",
    "    'text': '#2C3E50'           # Dark text\n",
    "}\n",
    "\n",
    "# Set professional matplotlib style\n",
    "plt.style.use('seaborn-v0_8-whitegrid')\n",
    "plt.rcParams.update({\n",
    "    'figure.figsize': (12, 7),\n",
    "    'font.size': 11,\n",
    "    'axes.labelsize': 12,\n",
    "    'axes.titlesize': 14,\n",
    "    'xtick.labelsize': 10,\n",
    "    'ytick.labelsize': 10,\n",
    "    'legend.fontsize': 10,\n",
    "    'figure.titlesize': 16,\n",
    "    'axes.facecolor': COLORS['background'],\n",
    "    'figure.facecolor': 'white',\n",
    "    'axes.edgecolor': COLORS['neutral'],\n",
    "    'grid.color': COLORS['grid'],\n",
    "    'grid.alpha': 0.3,\n",
    "    'text.color': COLORS['text'],\n",
    "    'axes.labelcolor': COLORS['text'],\n",
    "    'xtick.color': COLORS['text'],\n",
    "    'ytick.color': COLORS['text']\n",
    "})\n",
    "\n",
    "# ================================================================\n",
    "# CONFIGURATION\n",
    "# ================================================================\n",
    "\n",
    "class Config:\n",
    "    BASE_PATH = Path(\"/kaggle/input/csiro-biomass/\")\n",
    "    TRAIN_PATH = BASE_PATH / \"train\"\n",
    "    TEST_PATH = BASE_PATH / \"test\"\n",
    "    OUTPUT_PATH = Path(\"/kaggle/working/\")\n",
    "    \n",
    "    TARGET_COLS = ['Dry_Green_g', 'Dry_Dead_g', 'Dry_Clover_g', 'GDM_g', 'Dry_Total_g']\n",
    "    TARGET_NAMES = {\n",
    "        'Dry_Green_g': 'Green Biomass',\n",
    "        'Dry_Dead_g': 'Dead Biomass',\n",
    "        'Dry_Clover_g': 'Clover Biomass',\n",
    "        'GDM_g': 'Green Dry Matter',\n",
    "        'Dry_Total_g': 'Total Biomass'\n",
    "    }\n",
    "    \n",
    "    TARGET_WEIGHTS = {\n",
    "        'Dry_Green_g': 0.1,\n",
    "        'Dry_Dead_g': 0.1,\n",
    "        'Dry_Clover_g': 0.1,\n",
    "        'GDM_g': 0.2,\n",
    "        'Dry_Total_g': 0.5,\n",
    "    }\n",
    "\n",
    "cfg = Config()\n",
    "\n",
    "print(\"=\"*80)\n",
    "print(\"CSIRO BIOMASS COMPETITION - PROFESSIONAL EDA\")\n",
    "print(\"=\"*80)\n",
    "\n",
    "# ================================================================\n",
    "# LOAD DATA\n",
    "# ================================================================\n",
    "\n",
    "print(\"\\nLoading data...\")\n",
    "train_df = pd.read_csv(cfg.BASE_PATH / \"train.csv\")\n",
    "test_df = pd.read_csv(cfg.BASE_PATH / \"test.csv\")\n",
    "\n",
    "print(f\"Train shape: {train_df.shape}\")\n",
    "print(f\"Test shape: {test_df.shape}\")\n",
    "\n",
    "# Pivot to get one row per image\n",
    "train_pivot = train_df.pivot_table(\n",
    "    values='target',\n",
    "    index='image_path',\n",
    "    columns='target_name',\n",
    "    aggfunc='mean'\n",
    ").reset_index()\n",
    "\n",
    "print(f\"Pivoted train shape: {train_pivot.shape}\")\n",
    "\n",
    "# ================================================================\n",
    "# 1. COMPREHENSIVE TARGET DISTRIBUTION WITH BELL CURVES\n",
    "# ================================================================\n",
    "\n",
    "print(\"\\n\" + \"=\"*80)\n",
    "print(\"Creating Visualization 1: Target Distributions with Normal Curves\")\n",
    "print(\"=\"*80)\n",
    "\n",
    "fig = plt.figure(figsize=(20, 12))\n",
    "gs = fig.add_gridspec(3, 2, hspace=0.3, wspace=0.25)\n",
    "\n",
    "for idx, col in enumerate(cfg.TARGET_COLS):\n",
    "    row = idx // 2\n",
    "    col_idx = idx % 2\n",
    "    ax = fig.add_subplot(gs[row, col_idx])\n",
    "    \n",
    "    values = train_pivot[col].dropna().values\n",
    "    \n",
    "    # Histogram\n",
    "    n, bins, patches = ax.hist(values, bins=40, alpha=0.6, color=COLORS['primary'], \n",
    "                                edgecolor='white', linewidth=1.5, density=True,\n",
    "                                label='Observed Distribution')\n",
    "    \n",
    "    # Fit normal distribution\n",
    "    mu, sigma = values.mean(), values.std()\n",
    "    x = np.linspace(values.min(), values.max(), 100)\n",
    "    normal_curve = norm.pdf(x, mu, sigma)\n",
    "    \n",
    "    # Plot normal curve\n",
    "    ax.plot(x, normal_curve, color=COLORS['highlight'], linewidth=3, \n",
    "            label=f'Normal Fit (μ={mu:.1f}, σ={sigma:.1f})', linestyle='--')\n",
    "    \n",
    "    # Statistics lines\n",
    "    ax.axvline(mu, color=COLORS['secondary'], linestyle='-', linewidth=2.5, \n",
    "               label=f'Mean: {mu:.2f}g', alpha=0.8)\n",
    "    ax.axvline(np.median(values), color=COLORS['tertiary'], linestyle='-', linewidth=2.5,\n",
    "               label=f'Median: {np.median(values):.2f}g', alpha=0.8)\n",
    "    \n",
    "    # Annotations\n",
    "    ax.text(0.98, 0.97, f'n = {len(values):,}', transform=ax.transAxes,\n",
    "            verticalalignment='top', horizontalalignment='right',\n",
    "            bbox=dict(boxstyle='round', facecolor='white', alpha=0.9, edgecolor=COLORS['neutral']),\n",
    "            fontsize=10, fontweight='bold')\n",
    "    \n",
    "    # Statistical properties\n",
    "    skewness = skew(values)\n",
    "    kurt = kurtosis(values)\n",
    "    stats_text = f'Skewness: {skewness:.2f}\\nKurtosis: {kurt:.2f}\\nMin: {values.min():.2f}g\\nMax: {values.max():.2f}g'\n",
    "    ax.text(0.02, 0.97, stats_text, transform=ax.transAxes,\n",
    "            verticalalignment='top', horizontalalignment='left',\n",
    "            bbox=dict(boxstyle='round', facecolor='white', alpha=0.9, edgecolor=COLORS['neutral']),\n",
    "            fontsize=9)\n",
    "    \n",
    "    # Labels and title\n",
    "    ax.set_xlabel(f'{cfg.TARGET_NAMES[col]} (grams)', fontsize=12, fontweight='bold')\n",
    "    ax.set_ylabel('Probability Density', fontsize=12, fontweight='bold')\n",
    "    ax.set_title(f'{cfg.TARGET_NAMES[col]} Distribution', \n",
    "                 fontsize=14, fontweight='bold', pad=15, color=COLORS['text'])\n",
    "    ax.legend(loc='upper right', framealpha=0.95, edgecolor=COLORS['neutral'])\n",
    "    ax.grid(True, alpha=0.3, linestyle='--')\n",
    "    ax.spines['top'].set_visible(False)\n",
    "    ax.spines['right'].set_visible(False)\n",
    "\n",
    "# Add overall title\n",
    "fig.suptitle('Target Variable Distributions with Statistical Analysis', \n",
    "             fontsize=18, fontweight='bold', y=0.995, color=COLORS['text'])\n",
    "\n",
    "plt.savefig(cfg.OUTPUT_PATH / 'professional_1_distributions.png', dpi=300, bbox_inches='tight', \n",
    "            facecolor='white', edgecolor='none')\n",
    "print(\"✓ Saved: professional_1_distributions.png\")\n",
    "plt.close()\n",
    "\n",
    "# ================================================================\n",
    "# 2. COMPREHENSIVE CORRELATION MATRIX  \n",
    "# ================================================================\n",
    "\n",
    "print(\"\\n\" + \"=\"*80)\n",
    "print(\"Creating Visualization 2: Complete Correlation Matrix\")\n",
    "print(\"=\"*80)\n",
    "\n",
    "# Calculate correlations\n",
    "correlation_matrix = train_pivot[cfg.TARGET_COLS].corr()\n",
    "\n",
    "# Create simple figure\n",
    "fig, ax = plt.subplots(figsize=(12, 10))\n",
    "\n",
    "# Professional RED-WHITE-GREEN diverging colormap\n",
    "# Red (negative) → White/Yellow (zero) → Green (positive)\n",
    "from matplotlib.colors import LinearSegmentedColormap\n",
    "colors_cmap = [\n",
    "    '#D73027',  # Dark red (strong negative)\n",
    "    '#FC8D59',  # Medium red\n",
    "    '#FEE090',  # Light red/orange\n",
    "    '#FFFFBF',  # White/Yellow (zero)\n",
    "    '#E0F3DB',  # Very light green\n",
    "    '#A8DDB5',  # Light green\n",
    "    '#66C2A4',  # Medium light green\n",
    "    '#2CA25F',  # Medium green\n",
    "    '#006D2C'   # Dark green (strong positive)\n",
    "]\n",
    "n_bins = 100\n",
    "cmap_diverging = LinearSegmentedColormap.from_list('red_white_green', colors_cmap, N=n_bins)\n",
    "\n",
    "# Create heatmap with full range -1 to 1\n",
    "im = ax.imshow(correlation_matrix, cmap=cmap_diverging, aspect='auto', vmin=-1, vmax=1)\n",
    "\n",
    "# Set ticks\n",
    "ax.set_xticks(np.arange(len(cfg.TARGET_COLS)))\n",
    "ax.set_yticks(np.arange(len(cfg.TARGET_COLS)))\n",
    "ax.set_xticklabels([cfg.TARGET_NAMES[col] for col in cfg.TARGET_COLS], \n",
    "                    rotation=45, ha='right', fontsize=11, fontweight='bold')\n",
    "ax.set_yticklabels([cfg.TARGET_NAMES[col] for col in cfg.TARGET_COLS], \n",
    "                    fontsize=11, fontweight='bold')\n",
    "\n",
    "# Add correlation values and significance\n",
    "for i in range(len(cfg.TARGET_COLS)):\n",
    "    for j in range(len(cfg.TARGET_COLS)):\n",
    "        corr_val = correlation_matrix.iloc[i, j]\n",
    "        \n",
    "        # Calculate p-value\n",
    "        if i != j:\n",
    "            _, p_val = pearsonr(train_pivot[cfg.TARGET_COLS[i]], \n",
    "                               train_pivot[cfg.TARGET_COLS[j]])\n",
    "            sig = '***' if p_val < 0.001 else '**' if p_val < 0.01 else '*' if p_val < 0.05 else ''\n",
    "        else:\n",
    "            sig = ''\n",
    "        \n",
    "        # Choose text color based on correlation value\n",
    "        # Dark text for light colors (near zero), white text for dark colors (strong correlations)\n",
    "        if abs(corr_val) > 0.6:\n",
    "            text_color = 'white'\n",
    "        else:\n",
    "            text_color = 'black'\n",
    "        \n",
    "        # Main correlation value\n",
    "        ax.text(j, i, f'{corr_val:.3f}', ha='center', va='center',\n",
    "                color=text_color, fontsize=12, fontweight='bold')\n",
    "        \n",
    "        # Significance stars\n",
    "        if sig:\n",
    "            ax.text(j, i + 0.35, sig, ha='center', va='center',\n",
    "                    color=text_color, fontsize=10, fontweight='bold')\n",
    "\n",
    "# Colorbar with professional labels\n",
    "cbar = plt.colorbar(im, ax=ax, fraction=0.046, pad=0.04)\n",
    "cbar.set_label('Pearson Correlation Coefficient (r)', rotation=270, labelpad=25, \n",
    "               fontsize=12, fontweight='bold')\n",
    "cbar.ax.tick_params(labelsize=10)\n",
    "\n",
    "# Add interpretive labels on colorbar\n",
    "cbar.ax.text(3.5, -0.9, 'Strong Negative', transform=cbar.ax.transData,\n",
    "            fontsize=9, fontweight='bold', color='#D73027', rotation=0)\n",
    "cbar.ax.text(3.5, 0.0, 'No Correlation', transform=cbar.ax.transData,\n",
    "            fontsize=9, fontweight='bold', color='#666666', rotation=0)\n",
    "cbar.ax.text(3.5, 0.9, 'Strong Positive', transform=cbar.ax.transData,\n",
    "            fontsize=9, fontweight='bold', color='#006D2C', rotation=0)\n",
    "\n",
    "# Title with significance legend\n",
    "title_text = 'Complete Correlation Matrix: All Target Variables\\n'\n",
    "title_text += 'Red = Negative | Yellow = Zero | Green = Positive  |  '\n",
    "title_text += '*** p<0.001, ** p<0.01, * p<0.05'\n",
    "ax.set_title(title_text, fontsize=13, fontweight='bold', pad=20, color=COLORS['text'])\n",
    "\n",
    "# Grid\n",
    "ax.set_xticks(np.arange(len(cfg.TARGET_COLS)) - 0.5, minor=True)\n",
    "ax.set_yticks(np.arange(len(cfg.TARGET_COLS)) - 0.5, minor=True)\n",
    "ax.grid(which='minor', color='white', linestyle='-', linewidth=2)\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.savefig(cfg.OUTPUT_PATH / 'professional_2_correlation_matrix.png', dpi=300, bbox_inches='tight',\n",
    "            facecolor='white', edgecolor='none')\n",
    "print(\"✓ Saved: professional_2_correlation_matrix.png\")\n",
    "plt.close()\n",
    "\n",
    "# ================================================================\n",
    "# 3. DETAILED BOX PLOTS WITH STATISTICS\n",
    "# ================================================================\n",
    "\n",
    "print(\"\\n\" + \"=\"*80)\n",
    "print(\"Creating Visualization 3: Detailed Box Plots\")\n",
    "print(\"=\"*80)\n",
    "\n",
    "fig, ax = plt.subplots(figsize=(16, 8))\n",
    "\n",
    "# Prepare data\n",
    "data_for_box = [train_pivot[col].dropna().values for col in cfg.TARGET_COLS]\n",
    "labels = [cfg.TARGET_NAMES[col] for col in cfg.TARGET_COLS]\n",
    "\n",
    "# Create box plot\n",
    "bp = ax.boxplot(data_for_box, labels=labels, patch_artist=True,\n",
    "                widths=0.6, showmeans=True,\n",
    "                meanprops=dict(marker='D', markerfacecolor=COLORS['highlight'], \n",
    "                              markeredgecolor='white', markersize=10),\n",
    "                medianprops=dict(color=COLORS['secondary'], linewidth=2.5),\n",
    "                boxprops=dict(facecolor=COLORS['primary'], alpha=0.7, \n",
    "                             edgecolor=COLORS['text'], linewidth=1.5),\n",
    "                whiskerprops=dict(color=COLORS['text'], linewidth=1.5),\n",
    "                capprops=dict(color=COLORS['text'], linewidth=1.5),\n",
    "                flierprops=dict(marker='o', markerfacecolor=COLORS['highlight'], \n",
    "                               markersize=5, alpha=0.5, markeredgecolor='none'))\n",
    "\n",
    "# Add detailed statistics\n",
    "for idx, (col, data) in enumerate(zip(cfg.TARGET_COLS, data_for_box)):\n",
    "    # Calculate statistics\n",
    "    q1 = np.percentile(data, 25)\n",
    "    median = np.median(data)\n",
    "    q3 = np.percentile(data, 75)\n",
    "    mean = np.mean(data)\n",
    "    iqr = q3 - q1\n",
    "    lower_whisker = q1 - 1.5 * iqr\n",
    "    upper_whisker = q3 + 1.5 * iqr\n",
    "    outliers = len(data[(data < lower_whisker) | (data > upper_whisker)])\n",
    "    \n",
    "    # Add text annotation\n",
    "    stats_text = f'Mean: {mean:.1f}g\\nMedian: {median:.1f}g\\nIQR: {iqr:.1f}g\\nOutliers: {outliers}'\n",
    "    ax.text(idx + 1, ax.get_ylim()[1] * 0.95, stats_text,\n",
    "            ha='center', va='top', fontsize=9,\n",
    "            bbox=dict(boxstyle='round', facecolor='white', alpha=0.9, \n",
    "                     edgecolor=COLORS['neutral']))\n",
    "\n",
    "# Labels and formatting\n",
    "ax.set_ylabel('Biomass (grams)', fontsize=13, fontweight='bold')\n",
    "ax.set_xlabel('Target Variables', fontsize=13, fontweight='bold')\n",
    "ax.set_title('Box Plot Analysis: Target Variables with Statistical Details', \n",
    "             fontsize=15, fontweight='bold', pad=20, color=COLORS['text'])\n",
    "\n",
    "# Legend\n",
    "legend_elements = [\n",
    "    plt.Line2D([0], [0], marker='D', color='w', label='Mean',\n",
    "              markerfacecolor=COLORS['highlight'], markersize=10),\n",
    "    plt.Line2D([0], [0], color=COLORS['secondary'], linewidth=2.5, label='Median'),\n",
    "    plt.Line2D([0], [0], marker='o', color='w', label='Outliers',\n",
    "              markerfacecolor=COLORS['highlight'], markersize=7, alpha=0.5)\n",
    "]\n",
    "ax.legend(handles=legend_elements, loc='upper right', framealpha=0.95, \n",
    "         edgecolor=COLORS['neutral'], fontsize=11)\n",
    "\n",
    "ax.grid(True, alpha=0.3, axis='y', linestyle='--')\n",
    "ax.set_axisbelow(True)\n",
    "plt.xticks(rotation=15, ha='right')\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.savefig(cfg.OUTPUT_PATH / 'professional_3_boxplots.png', dpi=300, bbox_inches='tight',\n",
    "            facecolor='white', edgecolor='none')\n",
    "print(\"✓ Saved: professional_3_boxplots.png\")\n",
    "plt.close()\n",
    "\n",
    "# ================================================================\n",
    "# 4. SCATTER PLOT MATRIX WITH REGRESSION LINES\n",
    "# ================================================================\n",
    "\n",
    "print(\"\\n\" + \"=\"*80)\n",
    "print(\"Creating Visualization 4: Scatter Plot Matrix\")\n",
    "print(\"=\"*80)\n",
    "\n",
    "# Select subset of targets for clarity\n",
    "main_targets = ['Dry_Green_g', 'Dry_Dead_g', 'GDM_g', 'Dry_Total_g']\n",
    "n_targets = len(main_targets)\n",
    "\n",
    "fig, axes = plt.subplots(n_targets, n_targets, figsize=(18, 18))\n",
    "\n",
    "for i, target1 in enumerate(main_targets):\n",
    "    for j, target2 in enumerate(main_targets):\n",
    "        ax = axes[i, j]\n",
    "        \n",
    "        if i == j:\n",
    "            # Diagonal: histogram with KDE\n",
    "            data = train_pivot[target1].dropna().values\n",
    "            ax.hist(data, bins=30, alpha=0.6, color=COLORS['primary'], \n",
    "                   edgecolor='white', density=True)\n",
    "            \n",
    "            # KDE\n",
    "            from scipy.stats import gaussian_kde\n",
    "            kde = gaussian_kde(data)\n",
    "            x_range = np.linspace(data.min(), data.max(), 100)\n",
    "            ax.plot(x_range, kde(x_range), color=COLORS['highlight'], \n",
    "                   linewidth=2.5, label='KDE')\n",
    "            \n",
    "            ax.set_ylabel('Density', fontsize=9)\n",
    "            if i == n_targets - 1:\n",
    "                ax.set_xlabel(cfg.TARGET_NAMES[target1], fontsize=10, fontweight='bold')\n",
    "        else:\n",
    "            # Off-diagonal: scatter plot\n",
    "            x_data = train_pivot[target2].dropna()\n",
    "            y_data = train_pivot[target1].dropna()\n",
    "            \n",
    "            # Align data\n",
    "            common_idx = x_data.index.intersection(y_data.index)\n",
    "            x_vals = x_data.loc[common_idx].values\n",
    "            y_vals = y_data.loc[common_idx].values\n",
    "            \n",
    "            # Scatter\n",
    "            ax.scatter(x_vals, y_vals, alpha=0.4, s=20, color=COLORS['primary'], \n",
    "                      edgecolors='none')\n",
    "            \n",
    "            # Regression line\n",
    "            if len(x_vals) > 1:\n",
    "                z = np.polyfit(x_vals, y_vals, 1)\n",
    "                p = np.poly1d(z)\n",
    "                x_line = np.linspace(x_vals.min(), x_vals.max(), 100)\n",
    "                ax.plot(x_line, p(x_line), color=COLORS['highlight'], \n",
    "                       linewidth=2.5, linestyle='--')\n",
    "                \n",
    "                # Correlation\n",
    "                r, p_val = pearsonr(x_vals, y_vals)\n",
    "                ax.text(0.05, 0.95, f'r={r:.3f}', transform=ax.transAxes,\n",
    "                       verticalalignment='top', fontsize=9, fontweight='bold',\n",
    "                       bbox=dict(boxstyle='round', facecolor='white', alpha=0.9))\n",
    "        \n",
    "        # Labels\n",
    "        if j == 0:\n",
    "            ax.set_ylabel(cfg.TARGET_NAMES[target1], fontsize=10, fontweight='bold')\n",
    "        if i == n_targets - 1:\n",
    "            ax.set_xlabel(cfg.TARGET_NAMES[target2], fontsize=10, fontweight='bold')\n",
    "        \n",
    "        ax.grid(True, alpha=0.2, linestyle='--')\n",
    "        ax.tick_params(labelsize=8)\n",
    "\n",
    "fig.suptitle('Scatter Plot Matrix: Pairwise Relationships Between Targets', \n",
    "             fontsize=16, fontweight='bold', y=0.995)\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.savefig(cfg.OUTPUT_PATH / 'professional_4_scatter_matrix.png', dpi=300, bbox_inches='tight',\n",
    "            facecolor='white', edgecolor='none')\n",
    "print(\"✓ Saved: professional_4_scatter_matrix.png\")\n",
    "plt.close()\n",
    "\n",
    "# ================================================================\n",
    "# 5. DETAILED SAMPLE IMAGE ANALYSIS\n",
    "# ================================================================\n",
    "\n",
    "print(\"\\n\" + \"=\"*80)\n",
    "print(\"Creating Visualization 5: Detailed Sample Image Analysis\")\n",
    "print(\"=\"*80)\n",
    "\n",
    "# Select 6 sample images\n",
    "sample_images = train_pivot['image_path'].sample(min(6, len(train_pivot)), random_state=42).tolist()\n",
    "\n",
    "fig = plt.figure(figsize=(20, 16))\n",
    "gs = fig.add_gridspec(6, 4, hspace=0.35, wspace=0.3)  # 6 rows, 4 columns\n",
    "\n",
    "for idx, img_path in enumerate(sample_images):\n",
    "    img_name = os.path.basename(img_path)\n",
    "    full_path = cfg.TRAIN_PATH / img_name\n",
    "    \n",
    "    img = cv2.imread(str(full_path))\n",
    "    if img is None:\n",
    "        continue\n",
    "    \n",
    "    img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n",
    "    img_hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)\n",
    "    \n",
    "    # Main image (left column)\n",
    "    ax_img = fig.add_subplot(gs[idx, 0])\n",
    "    ax_img.imshow(img_rgb)\n",
    "    ax_img.set_title(f'Sample {idx+1}', fontsize=12, fontweight='bold')\n",
    "    ax_img.axis('off')\n",
    "    \n",
    "    # Add image properties\n",
    "    h, w, _ = img_rgb.shape\n",
    "    green_ratio = img_rgb[:,:,1] / (img_rgb.sum(axis=2) + 1)\n",
    "    brightness = img_rgb.mean()\n",
    "    \n",
    "    props_text = f'Size: {w}×{h}\\nBrightness: {brightness:.1f}\\nGreen Ratio: {green_ratio.mean():.3f}'\n",
    "    ax_img.text(0.02, 0.98, props_text, transform=ax_img.transAxes,\n",
    "               verticalalignment='top', fontsize=9,\n",
    "               bbox=dict(boxstyle='round', facecolor='white', alpha=0.9))\n",
    "    \n",
    "    # RGB histogram\n",
    "    ax_hist = fig.add_subplot(gs[idx, 1])\n",
    "    colors_rgb = ['#E74C3C', '#27AE60', '#3498DB']  # Red, Green, Blue\n",
    "    labels_rgb = ['Red', 'Green', 'Blue']\n",
    "    \n",
    "    for c, color, label in zip(range(3), colors_rgb, labels_rgb):\n",
    "        hist = cv2.calcHist([img_rgb], [c], None, [256], [0, 256])\n",
    "        ax_hist.plot(hist, color=color, linewidth=2, label=label, alpha=0.7)\n",
    "    \n",
    "    ax_hist.set_xlabel('Pixel Value', fontsize=9)\n",
    "    ax_hist.set_ylabel('Frequency', fontsize=9)\n",
    "    ax_hist.set_title('RGB Distribution', fontsize=10, fontweight='bold')\n",
    "    ax_hist.legend(fontsize=8)\n",
    "    ax_hist.grid(True, alpha=0.3)\n",
    "    ax_hist.set_xlim([0, 256])\n",
    "    \n",
    "    # Green channel analysis\n",
    "    ax_green = fig.add_subplot(gs[idx, 2])\n",
    "    green_channel = img_rgb[:,:,1]\n",
    "    ax_green.imshow(green_channel, cmap='Greens')\n",
    "    ax_green.set_title('Green Channel', fontsize=10, fontweight='bold')\n",
    "    ax_green.axis('off')\n",
    "    \n",
    "    # Vegetation index\n",
    "    ax_veg = fig.add_subplot(gs[idx, 3])\n",
    "    ax_veg.imshow(green_ratio, cmap='RdYlGn', vmin=0, vmax=0.5)\n",
    "    ax_veg.set_title('Vegetation Index', fontsize=10, fontweight='bold')\n",
    "    ax_veg.axis('off')\n",
    "\n",
    "fig.suptitle('Detailed Sample Image Analysis: RGB, Green Channel, and Vegetation Index', \n",
    "             fontsize=16, fontweight='bold', y=0.995)\n",
    "\n",
    "plt.savefig(cfg.OUTPUT_PATH / 'professional_5_sample_images.png', dpi=300, bbox_inches='tight',\n",
    "            facecolor='white', edgecolor='none')\n",
    "print(\"✓ Saved: professional_5_sample_images.png\")\n",
    "plt.close()\n",
    "\n",
    "# ================================================================\n",
    "# 6. HIERARCHICAL RELATIONSHIP VALIDATION\n",
    "# ================================================================\n",
    "\n",
    "print(\"\\n\" + \"=\"*80)\n",
    "print(\"Creating Visualization 6: Hierarchical Relationships\")\n",
    "print(\"=\"*80)\n",
    "\n",
    "fig, axes = plt.subplots(1, 2, figsize=(18, 7))\n",
    "\n",
    "# Green + Clover = GDM\n",
    "ax = axes[0]\n",
    "calculated = train_pivot['Dry_Green_g'] + train_pivot['Dry_Clover_g']\n",
    "actual = train_pivot['GDM_g']\n",
    "\n",
    "ax.scatter(calculated, actual, alpha=0.5, s=40, color=COLORS['primary'], \n",
    "          edgecolors='white', linewidth=0.5)\n",
    "\n",
    "# Perfect match line\n",
    "max_val = max(calculated.max(), actual.max())\n",
    "ax.plot([0, max_val], [0, max_val], color=COLORS['highlight'], \n",
    "       linewidth=3, linestyle='--', label='Perfect Match (y=x)')\n",
    "\n",
    "# Regression line\n",
    "z = np.polyfit(calculated, actual, 1)\n",
    "p = np.poly1d(z)\n",
    "x_line = np.linspace(calculated.min(), calculated.max(), 100)\n",
    "ax.plot(x_line, p(x_line), color=COLORS['secondary'], \n",
    "       linewidth=2.5, label=f'Regression: y={z[0]:.3f}x+{z[1]:.2f}')\n",
    "\n",
    "# Statistics\n",
    "r, p_val = pearsonr(calculated, actual)\n",
    "rmse = np.sqrt(((calculated - actual) ** 2).mean())\n",
    "\n",
    "stats_text = f'Pearson r: {r:.4f}\\np-value: {p_val:.2e}\\nRMSE: {rmse:.2f}g\\nn: {len(calculated):,}'\n",
    "ax.text(0.05, 0.95, stats_text, transform=ax.transAxes,\n",
    "       verticalalignment='top', fontsize=11, fontweight='bold',\n",
    "       bbox=dict(boxstyle='round', facecolor='white', alpha=0.95, \n",
    "                edgecolor=COLORS['neutral'], linewidth=2))\n",
    "\n",
    "ax.set_xlabel('Green + Clover (calculated, grams)', fontsize=12, fontweight='bold')\n",
    "ax.set_ylabel('GDM (actual, grams)', fontsize=12, fontweight='bold')\n",
    "ax.set_title('Hierarchical Validation: Green + Clover = GDM', \n",
    "            fontsize=13, fontweight='bold', pad=15)\n",
    "ax.legend(loc='lower right', fontsize=11, framealpha=0.95)\n",
    "ax.grid(True, alpha=0.3, linestyle='--')\n",
    "\n",
    "# GDM + Dead = Total\n",
    "ax = axes[1]\n",
    "calculated = train_pivot['GDM_g'] + train_pivot['Dry_Dead_g']\n",
    "actual = train_pivot['Dry_Total_g']\n",
    "\n",
    "ax.scatter(calculated, actual, alpha=0.5, s=40, color=COLORS['primary'], \n",
    "          edgecolors='white', linewidth=0.5)\n",
    "\n",
    "max_val = max(calculated.max(), actual.max())\n",
    "ax.plot([0, max_val], [0, max_val], color=COLORS['highlight'], \n",
    "       linewidth=3, linestyle='--', label='Perfect Match (y=x)')\n",
    "\n",
    "z = np.polyfit(calculated, actual, 1)\n",
    "p = np.poly1d(z)\n",
    "x_line = np.linspace(calculated.min(), calculated.max(), 100)\n",
    "ax.plot(x_line, p(x_line), color=COLORS['secondary'], \n",
    "       linewidth=2.5, label=f'Regression: y={z[0]:.3f}x+{z[1]:.2f}')\n",
    "\n",
    "r, p_val = pearsonr(calculated, actual)\n",
    "rmse = np.sqrt(((calculated - actual) ** 2).mean())\n",
    "\n",
    "stats_text = f'Pearson r: {r:.4f}\\np-value: {p_val:.2e}\\nRMSE: {rmse:.2f}g\\nn: {len(calculated):,}'\n",
    "ax.text(0.05, 0.95, stats_text, transform=ax.transAxes,\n",
    "       verticalalignment='top', fontsize=11, fontweight='bold',\n",
    "       bbox=dict(boxstyle='round', facecolor='white', alpha=0.95, \n",
    "                edgecolor=COLORS['neutral'], linewidth=2))\n",
    "\n",
    "ax.set_xlabel('GDM + Dead (calculated, grams)', fontsize=12, fontweight='bold')\n",
    "ax.set_ylabel('Total Biomass (actual, grams)', fontsize=12, fontweight='bold')\n",
    "ax.set_title('Hierarchical Validation: GDM + Dead = Total', \n",
    "            fontsize=13, fontweight='bold', pad=15)\n",
    "ax.legend(loc='lower right', fontsize=11, framealpha=0.95)\n",
    "ax.grid(True, alpha=0.3, linestyle='--')\n",
    "\n",
    "fig.suptitle('Hierarchical Relationship Validation with Statistical Analysis', \n",
    "             fontsize=15, fontweight='bold', y=1.00)\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.savefig(cfg.OUTPUT_PATH / 'professional_6_hierarchical.png', dpi=300, bbox_inches='tight',\n",
    "            facecolor='white', edgecolor='none')\n",
    "print(\"✓ Saved: professional_6_hierarchical.png\")\n",
    "plt.close()\n",
    "\n",
    "# ================================================================\n",
    "# SUMMARY\n",
    "# ================================================================\n",
    "\n",
    "print(\"\\n\" + \"=\"*80)\n",
    "print(\"EDA COMPLETE - ALL VISUALIZATIONS SAVED\")\n",
    "print(\"=\"*80)\n",
    "print(\"\\nGenerated Professional Visualizations:\")\n",
    "print(\"  1. professional_1_distributions.png - Target distributions with bell curves\")\n",
    "print(\"  2. professional_2_correlation_matrix.png - Complete correlation analysis\")\n",
    "print(\"  3. professional_3_boxplots.png - Detailed box plots with statistics\")\n",
    "print(\"  4. professional_4_scatter_matrix.png - Scatter plot matrix with regression\")\n",
    "print(\"  5. professional_5_sample_images.png - Detailed image analysis\")\n",
    "print(\"  6. professional_6_hierarchical.png - Hierarchical relationship validation\")\n",
    "print(\"\\nAll visualizations use consistent professional color scheme\")\n",
    "print(\"Statistical details and annotations included on all plots\")\n",
    "print(\"=\"*80)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "cf8eabbd",
   "metadata": {
    "_cell_guid": "7a4c7cae-091c-4028-b8e6-ff938a8b294c",
    "_uuid": "6db1ea3c-4eb1-451c-9305-b7efb29cca6f",
    "collapsed": false,
    "execution": {
     "iopub.execute_input": "2025-12-27T04:03:52.672368Z",
     "iopub.status.busy": "2025-12-27T04:03:52.672113Z",
     "iopub.status.idle": "2025-12-27T04:12:07.014208Z",
     "shell.execute_reply": "2025-12-27T04:12:07.013264Z"
    },
    "jupyter": {
     "outputs_hidden": false
    },
    "papermill": {
     "duration": 494.348282,
     "end_time": "2025-12-27T04:12:07.015775",
     "exception": false,
     "start_time": "2025-12-27T04:03:52.667493",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "============================================================\n",
      "CSIRO BIOMASS - IMPROVED VERSION\n",
      "Target: 0.65+ CV Score\n",
      "============================================================\n",
      "\n",
      "1. Loading data...\n",
      "Train: (1785, 9)\n",
      "Test: (5, 3)\n",
      "\n",
      "2. Pivoting data...\n",
      "Train pivot: (357, 6)\n",
      "Test unique: (1, 3)\n",
      "\n",
      "3. Extracting advanced features...\n",
      "Extracting advanced features from images...\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "ffd0467f6f2545bfbe9be0b03cb2c65b",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "Processing images:   0%|          | 0/357 [00:00<?, ?it/s]"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Cached features to /kaggle/working/train_features_advanced.parquet\n",
      "Extracting advanced features from images...\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "166625014fa04be3930929dbdbecbec6",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "Processing images:   0%|          | 0/1 [00:00<?, ?it/s]"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Cached features to /kaggle/working/test_features_advanced.parquet\n",
      "Number of features: 122\n",
      "\n",
      "4. Training advanced models...\n",
      "Features: 122 -> PCA: 10\n",
      "\n",
      "============================================================\n",
      "Fold 1/5\n",
      "============================================================\n",
      "  Dry_Green_g: R² = 0.1270\n",
      "  Dry_Dead_g: R² = 0.2357\n",
      "  Dry_Clover_g: R² = 0.1228\n",
      "  GDM_g: R² = 0.3096\n",
      "  Dry_Total_g: R² = 0.1242\n",
      "\n",
      "Fold 1 Competition Score: 0.3896\n",
      "\n",
      "============================================================\n",
      "Fold 2/5\n",
      "============================================================\n",
      "  Dry_Green_g: R² = 0.3999\n",
      "  Dry_Dead_g: R² = 0.1634\n",
      "  Dry_Clover_g: R² = 0.3702\n",
      "  GDM_g: R² = 0.3703\n",
      "  Dry_Total_g: R² = 0.3776\n",
      "\n",
      "Fold 2 Competition Score: 0.5149\n",
      "\n",
      "============================================================\n",
      "Fold 3/5\n",
      "============================================================\n",
      "  Dry_Green_g: R² = 0.3169\n",
      "  Dry_Dead_g: R² = 0.1351\n",
      "  Dry_Clover_g: R² = 0.2437\n",
      "  GDM_g: R² = 0.4866\n",
      "  Dry_Total_g: R² = 0.4629\n",
      "\n",
      "Fold 3 Competition Score: 0.5703\n",
      "\n",
      "============================================================\n",
      "Fold 4/5\n",
      "============================================================\n",
      "  Dry_Green_g: R² = 0.2866\n",
      "  Dry_Dead_g: R² = 0.3469\n",
      "  Dry_Clover_g: R² = 0.3490\n",
      "  GDM_g: R² = 0.3675\n",
      "  Dry_Total_g: R² = 0.3237\n",
      "\n",
      "Fold 4 Competition Score: 0.4966\n",
      "\n",
      "============================================================\n",
      "Fold 5/5\n",
      "============================================================\n",
      "  Dry_Green_g: R² = 0.1273\n",
      "  Dry_Dead_g: R² = 0.4214\n",
      "  Dry_Clover_g: R² = 0.2064\n",
      "  GDM_g: R² = 0.1526\n",
      "  Dry_Total_g: R² = 0.2183\n",
      "\n",
      "Fold 5 Competition Score: 0.3983\n",
      "\n",
      "============================================================\n",
      "Overall CV Score: 0.4815\n",
      "============================================================\n",
      "\n",
      "5. Reconciling OOF predictions...\n",
      "Reconciled CV Score: 0.4830\n",
      "\n",
      "6. Predicting on test set...\n",
      "\n",
      "Generating predictions...\n",
      "\n",
      "7. Creating submission...\n",
      "\n",
      "============================================================\n",
      "✓ DONE!\n",
      "============================================================\n",
      "\n",
      "Submission shape: (5, 2)\n",
      "\n",
      "Target distribution:\n",
      "  Dry_Green_g: mean=13.53, std=0.00, min=13.53, max=13.53\n",
      "  Dry_Dead_g: mean=14.55, std=0.00, min=14.55, max=14.55\n",
      "  Dry_Clover_g: mean=6.08, std=0.00, min=6.08, max=6.08\n",
      "  GDM_g: mean=19.62, std=0.00, min=19.62, max=19.62\n",
      "  Dry_Total_g: mean=34.17, std=0.00, min=34.17, max=34.17\n",
      "\n",
      "Submission saved to: /kaggle/working/submission.csv\n"
     ]
    }
   ],
   "source": [
    "# ================================================================\n",
    "# CSIRO BIOMASS - IMPROVED HIGH-PERFORMANCE VERSION\n",
    "# ================================================================\n",
    "# Advanced features + ensemble + better modeling\n",
    "# Target: 0.65+ CV score\n",
    "# ================================================================\n",
    "\n",
    "import os\n",
    "import gc\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "import cv2\n",
    "from pathlib import Path\n",
    "from tqdm.auto import tqdm\n",
    "import warnings\n",
    "warnings.filterwarnings('ignore')\n",
    "\n",
    "from sklearn.model_selection import KFold\n",
    "from sklearn.preprocessing import StandardScaler, RobustScaler\n",
    "from sklearn.decomposition import PCA\n",
    "from sklearn.linear_model import Ridge, Lasso\n",
    "from lightgbm import LGBMRegressor\n",
    "from catboost import CatBoostRegressor\n",
    "from xgboost import XGBRegressor\n",
    "from sklearn.ensemble import StackingRegressor, VotingRegressor\n",
    "\n",
    "# ================================================================\n",
    "# Configuration\n",
    "# ================================================================\n",
    "\n",
    "class Config:\n",
    "    BASE_PATH = Path(\"/kaggle/input/csiro-biomass/\")\n",
    "    TRAIN_PATH = BASE_PATH / \"train\"\n",
    "    TEST_PATH = BASE_PATH / \"test\"\n",
    "    \n",
    "    SEED = 42\n",
    "    N_FOLDS = 5\n",
    "    \n",
    "    TARGET_COLS = ['Dry_Green_g', 'Dry_Dead_g', 'Dry_Clover_g', 'GDM_g', 'Dry_Total_g']\n",
    "    TARGET_WEIGHTS = {\n",
    "        'Dry_Green_g': 0.1,\n",
    "        'Dry_Dead_g': 0.1,\n",
    "        'Dry_Clover_g': 0.1,\n",
    "        'GDM_g': 0.2,\n",
    "        'Dry_Total_g': 0.5,\n",
    "    }\n",
    "\n",
    "cfg = Config()\n",
    "\n",
    "# ================================================================\n",
    "# Utility Functions\n",
    "# ================================================================\n",
    "\n",
    "def set_seed(seed=42):\n",
    "    np.random.seed(seed)\n",
    "    import random\n",
    "    random.seed(seed)\n",
    "    os.environ['PYTHONHASHSEED'] = str(seed)\n",
    "\n",
    "def competition_metric(y_true, y_pred):\n",
    "    \"\"\"Competition metric - weighted R²\"\"\"\n",
    "    weights = np.array([cfg.TARGET_WEIGHTS[col] for col in cfg.TARGET_COLS])\n",
    "    y_weighted = np.sum(y_true.mean(axis=0) * weights)\n",
    "    ss_res = np.sum(((y_true - y_pred) ** 2).mean(axis=0) * weights)\n",
    "    ss_tot = np.sum(((y_true - y_weighted) ** 2).mean(axis=0) * weights)\n",
    "    return 1 - ss_res / ss_tot\n",
    "\n",
    "def reconcile_predictions(df):\n",
    "    \"\"\"Apply hierarchical reconciliation\"\"\"\n",
    "    df = df.copy()\n",
    "    for col in cfg.TARGET_COLS:\n",
    "        df[col] = df[col].clip(lower=0)\n",
    "    \n",
    "    ordered_cols = [\"Dry_Green_g\", \"Dry_Clover_g\", \"Dry_Dead_g\", \"GDM_g\", \"Dry_Total_g\"]\n",
    "    Y = df[ordered_cols].values.T\n",
    "    \n",
    "    C = np.array([[1, 1, 0, -1, 0], [0, 0, 1, 1, -1]])\n",
    "    C_T = C.T\n",
    "    inv_CCt = np.linalg.inv(C @ C_T)\n",
    "    P = np.eye(5) - C_T @ inv_CCt @ C\n",
    "    Y_reconciled = P @ Y\n",
    "    Y_reconciled = Y_reconciled.T.clip(min=0)\n",
    "    \n",
    "    df[ordered_cols] = Y_reconciled\n",
    "    return df\n",
    "\n",
    "# ================================================================\n",
    "# Advanced Feature Extraction\n",
    "# ================================================================\n",
    "\n",
    "def extract_advanced_features(image_path, use_ndvi=True):\n",
    "    \"\"\"Extract comprehensive features from images\"\"\"\n",
    "    img = cv2.imread(str(image_path))\n",
    "    if img is None:\n",
    "        return np.zeros(120)\n",
    "    \n",
    "    img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n",
    "    img_hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)\n",
    "    img_lab = cv2.cvtColor(img, cv2.COLOR_BGR2LAB)\n",
    "    img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n",
    "    \n",
    "    h, w, _ = img_rgb.shape\n",
    "    mid = w // 2\n",
    "    left = img_rgb[:, :mid]\n",
    "    right = img_rgb[:, mid:]\n",
    "    \n",
    "    features = []\n",
    "    \n",
    "    # ===== 1. RGB COLOR STATISTICS (18 features) =====\n",
    "    for channel in range(3):\n",
    "        features.extend([\n",
    "            img_rgb[:, :, channel].mean(),\n",
    "            img_rgb[:, :, channel].std(),\n",
    "            np.percentile(img_rgb[:, :, channel], 25),\n",
    "            np.percentile(img_rgb[:, :, channel], 50),\n",
    "            np.percentile(img_rgb[:, :, channel], 75),\n",
    "            img_rgb[:, :, channel].max()\n",
    "        ])\n",
    "    \n",
    "    # ===== 2. HSV COLOR FEATURES (18 features) =====\n",
    "    for channel in range(3):\n",
    "        features.extend([\n",
    "            img_hsv[:, :, channel].mean(),\n",
    "            img_hsv[:, :, channel].std(),\n",
    "            np.percentile(img_hsv[:, :, channel], 25),\n",
    "            np.percentile(img_hsv[:, :, channel], 50),\n",
    "            np.percentile(img_hsv[:, :, channel], 75),\n",
    "            img_hsv[:, :, channel].max()\n",
    "        ])\n",
    "    \n",
    "    # ===== 3. LAB COLOR FEATURES (18 features) =====\n",
    "    for channel in range(3):\n",
    "        features.extend([\n",
    "            img_lab[:, :, channel].mean(),\n",
    "            img_lab[:, :, channel].std(),\n",
    "            np.percentile(img_lab[:, :, channel], 25),\n",
    "            np.percentile(img_lab[:, :, channel], 50),\n",
    "            np.percentile(img_lab[:, :, channel], 75),\n",
    "            img_lab[:, :, channel].max()\n",
    "        ])\n",
    "    \n",
    "    # ===== 4. VEGETATION INDICES (10 features) =====\n",
    "    R = img_rgb[:, :, 0].astype(float) + 1\n",
    "    G = img_rgb[:, :, 1].astype(float) + 1\n",
    "    B = img_rgb[:, :, 2].astype(float) + 1\n",
    "    \n",
    "    # Green ratio (key for vegetation)\n",
    "    green_ratio = G / (R + G + B)\n",
    "    features.extend([\n",
    "        green_ratio.mean(),\n",
    "        green_ratio.std(),\n",
    "        np.percentile(green_ratio, 75)\n",
    "    ])\n",
    "    \n",
    "    # Excess Green Index\n",
    "    ExG = 2 * G - R - B\n",
    "    features.extend([\n",
    "        ExG.mean(),\n",
    "        ExG.std()\n",
    "    ])\n",
    "    \n",
    "    # Green-Red Vegetation Index\n",
    "    GRVI = (G - R) / (G + R)\n",
    "    features.extend([\n",
    "        GRVI.mean(),\n",
    "        GRVI.std()\n",
    "    ])\n",
    "    \n",
    "    # Visible Atmospherically Resistant Index\n",
    "    VARI = (G - R) / (G + R - B + 1e-6)\n",
    "    features.extend([\n",
    "        VARI.mean(),\n",
    "        VARI.std()\n",
    "    ])\n",
    "    \n",
    "    # Normalized Green-Blue Difference Index\n",
    "    NGBDI = (G - B) / (G + B + 1e-6)\n",
    "    features.append(NGBDI.mean())\n",
    "    \n",
    "    # ===== 5. TEXTURE FEATURES (15 features) =====\n",
    "    # Edge detection\n",
    "    edges = cv2.Canny(img_gray, 50, 150)\n",
    "    features.extend([\n",
    "        edges.mean(),\n",
    "        edges.std(),\n",
    "        np.count_nonzero(edges) / edges.size\n",
    "    ])\n",
    "    \n",
    "    # Sobel gradients\n",
    "    sobelx = cv2.Sobel(img_gray, cv2.CV_64F, 1, 0, ksize=3)\n",
    "    sobely = cv2.Sobel(img_gray, cv2.CV_64F, 0, 1, ksize=3)\n",
    "    gradient_magnitude = np.sqrt(sobelx**2 + sobely**2)\n",
    "    features.extend([\n",
    "        gradient_magnitude.mean(),\n",
    "        gradient_magnitude.std()\n",
    "    ])\n",
    "    \n",
    "    # Laplacian (texture detail)\n",
    "    laplacian = cv2.Laplacian(img_gray, cv2.CV_64F)\n",
    "    features.extend([\n",
    "        laplacian.mean(),\n",
    "        laplacian.std(),\n",
    "        np.abs(laplacian).mean()\n",
    "    ])\n",
    "    \n",
    "    # Gray level statistics\n",
    "    features.extend([\n",
    "        img_gray.mean(),\n",
    "        img_gray.std(),\n",
    "        np.percentile(img_gray, 25),\n",
    "        np.percentile(img_gray, 50),\n",
    "        np.percentile(img_gray, 75),\n",
    "        img_gray.max(),\n",
    "        img_gray.min()\n",
    "    ])\n",
    "    \n",
    "    # ===== 6. SPATIAL FEATURES (12 features) =====\n",
    "    # Left vs Right comparison (grazing patterns)\n",
    "    for channel in range(3):\n",
    "        features.append(left[:, :, channel].mean() - right[:, :, channel].mean())\n",
    "        features.append(left[:, :, channel].std() - right[:, :, channel].std())\n",
    "    \n",
    "    # Top vs Bottom comparison (growth patterns)\n",
    "    top = img_rgb[:h//2, :]\n",
    "    bottom = img_rgb[h//2:, :]\n",
    "    for channel in range(3):\n",
    "        features.append(top[:, :, channel].mean() - bottom[:, :, channel].mean())\n",
    "        features.append(top[:, :, channel].std() - bottom[:, :, channel].std())\n",
    "    \n",
    "    # ===== 7. COLOR HISTOGRAMS (15 features) =====\n",
    "    for channel in range(3):\n",
    "        hist = cv2.calcHist([img_rgb], [channel], None, [8], [0, 256])\n",
    "        hist = hist.flatten() / hist.sum()  # Normalize\n",
    "        features.extend(hist[:5])  # Use first 5 bins\n",
    "    \n",
    "    # ===== 8. SATURATION & BRIGHTNESS (10 features) =====\n",
    "    saturation = img_hsv[:, :, 1]\n",
    "    value = img_hsv[:, :, 2]\n",
    "    \n",
    "    features.extend([\n",
    "        saturation.mean(),\n",
    "        saturation.std(),\n",
    "        np.percentile(saturation, 25),\n",
    "        np.percentile(saturation, 75),\n",
    "        (saturation > 50).mean()  # High saturation ratio\n",
    "    ])\n",
    "    \n",
    "    features.extend([\n",
    "        value.mean(),\n",
    "        value.std(),\n",
    "        np.percentile(value, 25),\n",
    "        np.percentile(value, 75),\n",
    "        (value > 128).mean()  # Brightness ratio\n",
    "    ])\n",
    "    \n",
    "    # ===== 9. COLOR MOMENTS (6 features) =====\n",
    "    # Skewness and kurtosis for RGB\n",
    "    from scipy.stats import skew, kurtosis\n",
    "    for channel in range(3):\n",
    "        features.append(skew(img_rgb[:, :, channel].flatten()))\n",
    "        features.append(kurtosis(img_rgb[:, :, channel].flatten()))\n",
    "    \n",
    "    return np.array(features)\n",
    "\n",
    "def load_or_create_features(df, image_dir, feature_cache_path=None):\n",
    "    \"\"\"Load pre-computed features or create them\"\"\"\n",
    "    \n",
    "    if feature_cache_path and os.path.exists(feature_cache_path):\n",
    "        print(f\"Loading cached features from {feature_cache_path}\")\n",
    "        cached_df = pd.read_parquet(feature_cache_path)\n",
    "        return cached_df\n",
    "    \n",
    "    print(\"Extracting advanced features from images...\")\n",
    "    features_list = []\n",
    "    image_paths = []\n",
    "    \n",
    "    for idx in tqdm(range(len(df)), desc=\"Processing images\"):\n",
    "        row = df.iloc[idx]\n",
    "        img_path_value = row['image_path']\n",
    "        \n",
    "        if isinstance(img_path_value, str):\n",
    "            img_name = os.path.basename(img_path_value)\n",
    "        else:\n",
    "            img_name = os.path.basename(str(img_path_value))\n",
    "        \n",
    "        img_path = image_dir / img_name\n",
    "        \n",
    "        try:\n",
    "            features = extract_advanced_features(img_path)\n",
    "        except Exception as e:\n",
    "            print(f\"Error processing {img_path}: {e}\")\n",
    "            features = np.zeros(120)\n",
    "        \n",
    "        features_list.append(features)\n",
    "        image_paths.append(img_path_value)\n",
    "    \n",
    "    # Create feature dataframe\n",
    "    n_features = len(features_list[0])\n",
    "    feature_cols = [f'feat_{i}' for i in range(n_features)]\n",
    "    feature_df = pd.DataFrame(features_list, columns=feature_cols)\n",
    "    feature_df['image_path'] = image_paths\n",
    "    \n",
    "    # Add target columns if they exist\n",
    "    for col in cfg.TARGET_COLS:\n",
    "        if col in df.columns:\n",
    "            feature_df[col] = df[col].values\n",
    "    \n",
    "    # Add metadata if available\n",
    "    metadata_cols = ['Sampling_Date', 'State', 'Species', 'Pre_GSHH_NDVI', 'Height_Ave_cm']\n",
    "    for col in metadata_cols:\n",
    "        if col in df.columns:\n",
    "            feature_df[col] = df[col].values\n",
    "    \n",
    "    if feature_cache_path:\n",
    "        feature_df.to_parquet(feature_cache_path, index=False)\n",
    "        print(f\"Cached features to {feature_cache_path}\")\n",
    "    \n",
    "    return feature_df\n",
    "\n",
    "# ================================================================\n",
    "# Advanced Model Training\n",
    "# ================================================================\n",
    "\n",
    "def create_model_for_target(target_name):\n",
    "    \"\"\"Create optimized model for specific target\"\"\"\n",
    "    \n",
    "    # Base models with different characteristics\n",
    "    lgb = LGBMRegressor(\n",
    "        n_estimators=500,\n",
    "        learning_rate=0.03,\n",
    "        max_depth=7,\n",
    "        num_leaves=63,\n",
    "        min_child_samples=20,\n",
    "        subsample=0.8,\n",
    "        colsample_bytree=0.8,\n",
    "        reg_alpha=0.1,\n",
    "        reg_lambda=0.1,\n",
    "        random_state=cfg.SEED,\n",
    "        verbose=-1,\n",
    "        n_jobs=-1\n",
    "    )\n",
    "    \n",
    "    xgb = XGBRegressor(\n",
    "        n_estimators=500,\n",
    "        learning_rate=0.03,\n",
    "        max_depth=7,\n",
    "        min_child_weight=3,\n",
    "        subsample=0.8,\n",
    "        colsample_bytree=0.8,\n",
    "        reg_alpha=0.1,\n",
    "        reg_lambda=0.1,\n",
    "        random_state=cfg.SEED,\n",
    "        n_jobs=-1,\n",
    "        tree_method='hist'\n",
    "    )\n",
    "    \n",
    "    cat = CatBoostRegressor(\n",
    "        iterations=500,\n",
    "        learning_rate=0.03,\n",
    "        depth=7,\n",
    "        l2_leaf_reg=3,\n",
    "        random_state=cfg.SEED,\n",
    "        verbose=0,\n",
    "        thread_count=-1\n",
    "    )\n",
    "    \n",
    "    # Voting ensemble\n",
    "    model = VotingRegressor([\n",
    "        ('lgb', lgb),\n",
    "        ('xgb', xgb),\n",
    "        ('cat', cat)\n",
    "    ])\n",
    "    \n",
    "    return model\n",
    "\n",
    "def train_advanced_model(train_df, feature_cols):\n",
    "    \"\"\"Train advanced ensemble model\"\"\"\n",
    "    \n",
    "    set_seed(cfg.SEED)\n",
    "    kfold = KFold(n_splits=cfg.N_FOLDS, shuffle=True, random_state=cfg.SEED)\n",
    "    \n",
    "    X = train_df[feature_cols].values\n",
    "    \n",
    "    # Robust scaling (handles outliers better)\n",
    "    scaler = RobustScaler()\n",
    "    X_scaled = scaler.fit_transform(X)\n",
    "    \n",
    "    # PCA with more components\n",
    "    pca = PCA(n_components=0.98, random_state=cfg.SEED)\n",
    "    X_pca = pca.fit_transform(X_scaled)\n",
    "    \n",
    "    print(f\"Features: {X.shape[1]} -> PCA: {X_pca.shape[1]}\")\n",
    "    \n",
    "    oof_predictions = np.zeros((len(train_df), len(cfg.TARGET_COLS)))\n",
    "    models = []\n",
    "    \n",
    "    for fold, (train_idx, val_idx) in enumerate(kfold.split(train_df)):\n",
    "        print(f\"\\n{'='*60}\")\n",
    "        print(f\"Fold {fold + 1}/{cfg.N_FOLDS}\")\n",
    "        print(f\"{'='*60}\")\n",
    "        \n",
    "        X_train = X_pca[train_idx]\n",
    "        X_val = X_pca[val_idx]\n",
    "        \n",
    "        fold_models = []\n",
    "        \n",
    "        for target_idx, target_col in enumerate(cfg.TARGET_COLS):\n",
    "            y_train = train_df.iloc[train_idx][target_col].values\n",
    "            y_val = train_df.iloc[val_idx][target_col].values\n",
    "            \n",
    "            # Create and train model\n",
    "            model = create_model_for_target(target_col)\n",
    "            model.fit(X_train, y_train)\n",
    "            \n",
    "            # Predict\n",
    "            pred = model.predict(X_val)\n",
    "            pred = np.clip(pred, 0, None)  # Ensure non-negative\n",
    "            \n",
    "            oof_predictions[val_idx, target_idx] = pred\n",
    "            fold_models.append(model)\n",
    "            \n",
    "            # Calculate individual target R²\n",
    "            ss_res = ((y_val - pred) ** 2).mean()\n",
    "            ss_tot = ((y_val - y_val.mean()) ** 2).mean()\n",
    "            r2 = 1 - ss_res / ss_tot\n",
    "            print(f\"  {target_col}: R² = {r2:.4f}\")\n",
    "        \n",
    "        models.append(fold_models)\n",
    "        \n",
    "        # Calculate fold score\n",
    "        fold_score = competition_metric(\n",
    "            train_df.iloc[val_idx][cfg.TARGET_COLS].values,\n",
    "            oof_predictions[val_idx]\n",
    "        )\n",
    "        print(f\"\\nFold {fold + 1} Competition Score: {fold_score:.4f}\")\n",
    "    \n",
    "    # Overall CV score\n",
    "    cv_score = competition_metric(\n",
    "        train_df[cfg.TARGET_COLS].values,\n",
    "        oof_predictions\n",
    "    )\n",
    "    \n",
    "    print(f\"\\n{'='*60}\")\n",
    "    print(f\"Overall CV Score: {cv_score:.4f}\")\n",
    "    print(f\"{'='*60}\")\n",
    "    \n",
    "    return models, scaler, pca, oof_predictions\n",
    "\n",
    "# ================================================================\n",
    "# Inference\n",
    "# ================================================================\n",
    "\n",
    "def predict_advanced(test_df, models, scaler, pca, feature_cols):\n",
    "    \"\"\"Advanced prediction with ensemble\"\"\"\n",
    "    \n",
    "    print(\"\\nGenerating predictions...\")\n",
    "    \n",
    "    X_test = test_df[feature_cols].values\n",
    "    X_test_scaled = scaler.transform(X_test)\n",
    "    X_test_pca = pca.transform(X_test_scaled)\n",
    "    \n",
    "    predictions = np.zeros((len(test_df), len(cfg.TARGET_COLS)))\n",
    "    \n",
    "    # Average predictions across all folds\n",
    "    for fold_idx, fold_models in enumerate(models):\n",
    "        for target_idx, model in enumerate(fold_models):\n",
    "            pred = model.predict(X_test_pca)\n",
    "            pred = np.clip(pred, 0, None)\n",
    "            predictions[:, target_idx] += pred\n",
    "    \n",
    "    predictions /= len(models)\n",
    "    \n",
    "    return predictions\n",
    "\n",
    "# ================================================================\n",
    "# Main Execution\n",
    "# ================================================================\n",
    "\n",
    "def main():\n",
    "    print(\"=\"*60)\n",
    "    print(\"CSIRO BIOMASS - IMPROVED VERSION\")\n",
    "    print(\"Target: 0.65+ CV Score\")\n",
    "    print(\"=\"*60)\n",
    "    \n",
    "    set_seed(cfg.SEED)\n",
    "    \n",
    "    # Load data\n",
    "    print(\"\\n1. Loading data...\")\n",
    "    train_df = pd.read_csv(cfg.BASE_PATH / \"train.csv\")\n",
    "    test_df = pd.read_csv(cfg.BASE_PATH / \"test.csv\")\n",
    "    \n",
    "    print(f\"Train: {train_df.shape}\")\n",
    "    print(f\"Test: {test_df.shape}\")\n",
    "    \n",
    "    # Pivot train data\n",
    "    print(\"\\n2. Pivoting data...\")\n",
    "    train_pivot = train_df.pivot_table(\n",
    "        values='target',\n",
    "        index='image_path',\n",
    "        columns='target_name',\n",
    "        aggfunc='mean'\n",
    "    ).reset_index()\n",
    "    \n",
    "    # Ensure numeric\n",
    "    for col in cfg.TARGET_COLS:\n",
    "        if col in train_pivot.columns:\n",
    "            train_pivot[col] = pd.to_numeric(train_pivot[col], errors='coerce').fillna(0.0)\n",
    "    \n",
    "    train_pivot['image_path'] = train_pivot['image_path'].apply(\n",
    "        lambda x: os.path.basename(x) if isinstance(x, str) else x\n",
    "    )\n",
    "    \n",
    "    test_unique = test_df.drop_duplicates('image_path').reset_index(drop=True)\n",
    "    test_unique['image_path'] = test_unique['image_path'].apply(\n",
    "        lambda x: os.path.basename(x) if isinstance(x, str) else x\n",
    "    )\n",
    "    \n",
    "    print(f\"Train pivot: {train_pivot.shape}\")\n",
    "    print(f\"Test unique: {test_unique.shape}\")\n",
    "    \n",
    "    # Extract features\n",
    "    print(\"\\n3. Extracting advanced features...\")\n",
    "    train_features = load_or_create_features(\n",
    "        train_pivot,\n",
    "        cfg.TRAIN_PATH,\n",
    "        feature_cache_path='/kaggle/working/train_features_advanced.parquet'\n",
    "    )\n",
    "    \n",
    "    test_features = load_or_create_features(\n",
    "        test_unique,\n",
    "        cfg.TEST_PATH,\n",
    "        feature_cache_path='/kaggle/working/test_features_advanced.parquet'\n",
    "    )\n",
    "    \n",
    "    feature_cols = [col for col in train_features.columns if col.startswith('feat_')]\n",
    "    print(f\"Number of features: {len(feature_cols)}\")\n",
    "    \n",
    "    # Train models\n",
    "    print(\"\\n4. Training advanced models...\")\n",
    "    models, scaler, pca, oof_preds = train_advanced_model(train_features, feature_cols)\n",
    "    \n",
    "    # Apply reconciliation to OOF\n",
    "    print(\"\\n5. Reconciling OOF predictions...\")\n",
    "    oof_df = pd.DataFrame(oof_preds, columns=cfg.TARGET_COLS)\n",
    "    oof_reconciled = reconcile_predictions(oof_df)\n",
    "    \n",
    "    reconciled_score = competition_metric(\n",
    "        train_features[cfg.TARGET_COLS].values,\n",
    "        oof_reconciled.values\n",
    "    )\n",
    "    print(f\"Reconciled CV Score: {reconciled_score:.4f}\")\n",
    "    \n",
    "    # Predict on test\n",
    "    print(\"\\n6. Predicting on test set...\")\n",
    "    test_preds = predict_advanced(test_features, models, scaler, pca, feature_cols)\n",
    "    \n",
    "    # Create submission\n",
    "    print(\"\\n7. Creating submission...\")\n",
    "    pred_df = pd.DataFrame(test_preds, columns=cfg.TARGET_COLS)\n",
    "    pred_df['image_path'] = test_features['image_path'].values\n",
    "    pred_df = reconcile_predictions(pred_df)\n",
    "    \n",
    "    pred_long = pred_df.melt(\n",
    "        id_vars='image_path',\n",
    "        value_vars=cfg.TARGET_COLS,\n",
    "        var_name='target_name',\n",
    "        value_name='target'\n",
    "    )\n",
    "    \n",
    "    test_df['image_path_basename'] = test_df['image_path'].apply(\n",
    "        lambda x: os.path.basename(x) if isinstance(x, str) else x\n",
    "    )\n",
    "    pred_long['image_path_basename'] = pred_long['image_path'].apply(\n",
    "        lambda x: os.path.basename(x) if isinstance(x, str) else x\n",
    "    )\n",
    "    \n",
    "    submission = test_df[['sample_id', 'image_path_basename', 'target_name']].merge(\n",
    "        pred_long[['image_path_basename', 'target_name', 'target']],\n",
    "        on=['image_path_basename', 'target_name'],\n",
    "        how='left'\n",
    "    )[['sample_id', 'target']]\n",
    "    \n",
    "    submission.to_csv('/kaggle/working/submission.csv', index=False)\n",
    "    \n",
    "    print(\"\\n\" + \"=\"*60)\n",
    "    print(\"✓ DONE!\")\n",
    "    print(\"=\"*60)\n",
    "    print(f\"\\nSubmission shape: {submission.shape}\")\n",
    "    print(\"\\nTarget distribution:\")\n",
    "    for col in cfg.TARGET_COLS:\n",
    "        vals = pred_df[col].values\n",
    "        print(f\"  {col}: mean={vals.mean():.2f}, std={vals.std():.2f}, min={vals.min():.2f}, max={vals.max():.2f}\")\n",
    "    print(f\"\\nSubmission saved to: /kaggle/working/submission.csv\")\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "922b2f52",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-12-27T04:12:07.026475Z",
     "iopub.status.busy": "2025-12-27T04:12:07.026228Z",
     "iopub.status.idle": "2025-12-27T04:17:32.160971Z",
     "shell.execute_reply": "2025-12-27T04:17:32.160125Z"
    },
    "papermill": {
     "duration": 325.142063,
     "end_time": "2025-12-27T04:17:32.162487",
     "exception": false,
     "start_time": "2025-12-27T04:12:07.020424",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "============================================================\n",
      "CSIRO BIOMASS - EDA-INFORMED VERSION (FIXED)\n",
      "All recommendations implemented!\n",
      "============================================================\n",
      "\n",
      "1. Loading data...\n",
      "\n",
      "2. Pivoting data...\n",
      "\n",
      "3. Extracting EDA-informed features...\n",
      "Extracting EDA-informed features (150 features)...\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "d1e9ab9b066345f1abcca961b1f4623d",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "Processing images:   0%|          | 0/357 [00:00<?, ?it/s]"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Cached features to /kaggle/working/train_features_eda.parquet\n",
      "Extracting EDA-informed features (150 features)...\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "0318792581244540b44b60dce3e5981a",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "Processing images:   0%|          | 0/1 [00:00<?, ?it/s]"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Cached features to /kaggle/working/test_features_eda.parquet\n",
      "Features: 150\n",
      "\n",
      "4. Training EDA-informed model...\n",
      "Features: 150 -> PCA: 32\n",
      "\n",
      "============================================================\n",
      "Fold 1/5\n",
      "============================================================\n",
      "  Dry_Green_g: R² = 0.4363\n",
      "  Dry_Dead_g: R² = 0.2471\n",
      "  Dry_Clover_g: R² = 0.2298\n",
      "  GDM_g: R² = 0.5639\n",
      "  Dry_Total_g: R² = 0.3389 ⭐ (50% weight!)\n",
      "\n",
      "Fold 1 Score: 0.5521\n",
      "\n",
      "============================================================\n",
      "Fold 2/5\n",
      "============================================================\n",
      "  Dry_Green_g: R² = 0.2958\n",
      "  Dry_Dead_g: R² = 0.3186\n",
      "  Dry_Clover_g: R² = 0.3405\n",
      "  GDM_g: R² = 0.3184\n",
      "  Dry_Total_g: R² = 0.3087 ⭐ (50% weight!)\n",
      "\n",
      "Fold 2 Score: 0.4648\n",
      "\n",
      "============================================================\n",
      "Fold 3/5\n",
      "============================================================\n",
      "  Dry_Green_g: R² = 0.5659\n",
      "  Dry_Dead_g: R² = 0.1216\n",
      "  Dry_Clover_g: R² = 0.2118\n",
      "  GDM_g: R² = 0.5426\n",
      "  Dry_Total_g: R² = 0.5131 ⭐ (50% weight!)\n",
      "\n",
      "Fold 3 Score: 0.6209\n",
      "\n",
      "============================================================\n",
      "Fold 4/5\n",
      "============================================================\n",
      "  Dry_Green_g: R² = 0.4366\n",
      "  Dry_Dead_g: R² = 0.2545\n",
      "  Dry_Clover_g: R² = 0.2857\n",
      "  GDM_g: R² = 0.6079\n",
      "  Dry_Total_g: R² = 0.4765 ⭐ (50% weight!)\n",
      "\n",
      "Fold 4 Score: 0.6154\n",
      "\n",
      "============================================================\n",
      "Fold 5/5\n",
      "============================================================\n",
      "  Dry_Green_g: R² = 0.4402\n",
      "  Dry_Dead_g: R² = 0.2883\n",
      "  Dry_Clover_g: R² = -0.0003\n",
      "  GDM_g: R² = 0.4702\n",
      "  Dry_Total_g: R² = 0.4331 ⭐ (50% weight!)\n",
      "\n",
      "Fold 5 Score: 0.5721\n",
      "\n",
      "============================================================\n",
      "Overall CV Score: 0.5645\n",
      "============================================================\n",
      "\n",
      "5. Applying hierarchical reconciliation...\n",
      "Reconciled CV Score: 0.5729\n",
      "\n",
      "6. Predicting on test...\n",
      "\n",
      "Generating predictions...\n",
      "\n",
      "7. Creating submission...\n",
      "\n",
      "============================================================\n",
      "✓ EDA-INFORMED VERSION COMPLETE!\n",
      "============================================================\n",
      "\n",
      "Final CV Score: 0.5729\n",
      "\n",
      "All EDA Recommendations Applied:\n",
      "  ✓ Green channel emphasized (20 features)\n",
      "  ✓ Vegetation indices (6 types)\n",
      "  ✓ Spatial features (grazing patterns)\n",
      "  ✓ PowerTransform for skewness\n",
      "  ✓ Stronger model for Total (50% weight)\n",
      "  ✓ Hierarchical reconciliation\n"
     ]
    }
   ],
   "source": [
    "# ================================================================\n",
    "# CSIRO BIOMASS - EDA-INFORMED OPTIMIZED VERSION (FIXED)\n",
    "# ================================================================\n",
    "# Based on comprehensive EDA findings\n",
    "# Target: 0.75+ CV score with smart optimizations\n",
    "# ================================================================\n",
    "\n",
    "import os\n",
    "import gc\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "import cv2\n",
    "from pathlib import Path\n",
    "from tqdm.auto import tqdm\n",
    "import warnings\n",
    "warnings.filterwarnings('ignore')\n",
    "\n",
    "from sklearn.model_selection import KFold\n",
    "from sklearn.preprocessing import RobustScaler, PowerTransformer\n",
    "from sklearn.decomposition import PCA\n",
    "from lightgbm import LGBMRegressor\n",
    "from catboost import CatBoostRegressor\n",
    "from xgboost import XGBRegressor\n",
    "from sklearn.ensemble import VotingRegressor\n",
    "\n",
    "# ================================================================\n",
    "# Configuration (EDA-informed)\n",
    "# ================================================================\n",
    "\n",
    "class Config:\n",
    "    BASE_PATH = Path(\"/kaggle/input/csiro-biomass/\")\n",
    "    TRAIN_PATH = BASE_PATH / \"train\"\n",
    "    TEST_PATH = BASE_PATH / \"test\"\n",
    "    \n",
    "    SEED = 42\n",
    "    N_FOLDS = 5\n",
    "    \n",
    "    TARGET_COLS = ['Dry_Green_g', 'Dry_Dead_g', 'Dry_Clover_g', 'GDM_g', 'Dry_Total_g']\n",
    "    \n",
    "    # EDA Finding: Metric weights (Total is 50%!)\n",
    "    TARGET_WEIGHTS = {\n",
    "        'Dry_Green_g': 0.1,\n",
    "        'Dry_Dead_g': 0.1,\n",
    "        'Dry_Clover_g': 0.1,\n",
    "        'GDM_g': 0.2,\n",
    "        'Dry_Total_g': 0.5,  # Focus here!\n",
    "    }\n",
    "    \n",
    "    # EDA Finding: Focus on Total Biomass (50% weight)\n",
    "    FOCUS_TARGET = 'Dry_Total_g'\n",
    "\n",
    "cfg = Config()\n",
    "\n",
    "# ================================================================\n",
    "# Utility Functions\n",
    "# ================================================================\n",
    "\n",
    "def set_seed(seed=42):\n",
    "    np.random.seed(seed)\n",
    "    import random\n",
    "    random.seed(seed)\n",
    "    os.environ['PYTHONHASHSEED'] = str(seed)\n",
    "\n",
    "def competition_metric(y_true, y_pred):\n",
    "    \"\"\"Competition metric - weighted R²\"\"\"\n",
    "    weights = np.array([cfg.TARGET_WEIGHTS[col] for col in cfg.TARGET_COLS])\n",
    "    y_weighted = np.sum(y_true.mean(axis=0) * weights)\n",
    "    ss_res = np.sum(((y_true - y_pred) ** 2).mean(axis=0) * weights)\n",
    "    ss_tot = np.sum(((y_true - y_weighted) ** 2).mean(axis=0) * weights)\n",
    "    return 1 - ss_res / ss_tot\n",
    "\n",
    "def reconcile_predictions(df):\n",
    "    \"\"\"\n",
    "    EDA Finding: Apply hierarchical reconciliation\n",
    "    Green + Clover = GDM, GDM + Dead = Total\n",
    "    \"\"\"\n",
    "    df = df.copy()\n",
    "    for col in cfg.TARGET_COLS:\n",
    "        df[col] = df[col].clip(lower=0)\n",
    "    \n",
    "    ordered_cols = [\"Dry_Green_g\", \"Dry_Clover_g\", \"Dry_Dead_g\", \"GDM_g\", \"Dry_Total_g\"]\n",
    "    Y = df[ordered_cols].values.T\n",
    "    \n",
    "    C = np.array([[1, 1, 0, -1, 0], [0, 0, 1, 1, -1]])\n",
    "    C_T = C.T\n",
    "    inv_CCt = np.linalg.inv(C @ C_T)\n",
    "    P = np.eye(5) - C_T @ inv_CCt @ C\n",
    "    Y_reconciled = P @ Y\n",
    "    Y_reconciled = Y_reconciled.T.clip(min=0)\n",
    "    \n",
    "    df[ordered_cols] = Y_reconciled\n",
    "    return df\n",
    "\n",
    "# ================================================================\n",
    "# EDA-Informed Feature Extraction (FIXED)\n",
    "# ================================================================\n",
    "\n",
    "def extract_eda_features(image_path):\n",
    "    \"\"\"\n",
    "    Extract features based on EDA findings:\n",
    "    - Green channel is most informative\n",
    "    - Vegetation indices distinguish pasture density\n",
    "    - Spatial features for grazing patterns\n",
    "    Returns exactly 150 features\n",
    "    \"\"\"\n",
    "    img = cv2.imread(str(image_path))\n",
    "    if img is None:\n",
    "        return np.zeros(150)\n",
    "    \n",
    "    # Good balance: 1200×600\n",
    "    img = cv2.resize(img, (1200, 600), interpolation=cv2.INTER_LINEAR)\n",
    "    \n",
    "    img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n",
    "    img_hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)\n",
    "    img_lab = cv2.cvtColor(img, cv2.COLOR_BGR2LAB)\n",
    "    img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n",
    "    \n",
    "    h, w, _ = img_rgb.shape\n",
    "    \n",
    "    features = []\n",
    "    \n",
    "    # === EDA INSIGHT 1: Green channel is most informative (20 features) ===\n",
    "    green = img_rgb[:, :, 1]\n",
    "    features.extend([\n",
    "        green.mean(), green.std(), green.var(),\n",
    "        np.percentile(green, 5), np.percentile(green, 10),\n",
    "        np.percentile(green, 25), np.percentile(green, 50),\n",
    "        np.percentile(green, 75), np.percentile(green, 90),\n",
    "        np.percentile(green, 95),\n",
    "        green.max(), green.min(),\n",
    "        (green > 100).mean(), (green > 150).mean(), (green > 200).mean(),\n",
    "        (green < 50).mean(), (green < 100).mean(),\n",
    "        img_hsv[:, :, 1].mean(),  # Saturation (green intensity)\n",
    "        img_lab[:, :, 1].mean(),  # a* channel (green-red)\n",
    "        (img_lab[:, :, 1] < 128).mean()  # Green ratio in LAB\n",
    "    ])\n",
    "    \n",
    "    # === Standard RGB Statistics (18 features) ===\n",
    "    for channel in range(3):\n",
    "        ch = img_rgb[:, :, channel]\n",
    "        features.extend([\n",
    "            ch.mean(), ch.std(),\n",
    "            np.percentile(ch, 25), np.percentile(ch, 75),\n",
    "            ch.max(), ch.min()\n",
    "        ])\n",
    "    \n",
    "    # === HSV Statistics (18 features) ===\n",
    "    for channel in range(3):\n",
    "        ch = img_hsv[:, :, channel]\n",
    "        features.extend([\n",
    "            ch.mean(), ch.std(),\n",
    "            np.percentile(ch, 25), np.percentile(ch, 75),\n",
    "            ch.max(), ch.min()\n",
    "        ])\n",
    "    \n",
    "    # === LAB Statistics (18 features) ===\n",
    "    for channel in range(3):\n",
    "        ch = img_lab[:, :, channel]\n",
    "        features.extend([\n",
    "            ch.mean(), ch.std(),\n",
    "            np.percentile(ch, 25), np.percentile(ch, 75),\n",
    "            ch.max(), ch.min()\n",
    "        ])\n",
    "    \n",
    "    # === EDA INSIGHT 2: Vegetation indices (18 features) ===\n",
    "    R = img_rgb[:, :, 0].astype(float) + 1\n",
    "    G = img_rgb[:, :, 1].astype(float) + 1\n",
    "    B = img_rgb[:, :, 2].astype(float) + 1\n",
    "    \n",
    "    # Green ratio (key for biomass)\n",
    "    green_ratio = G / (R + G + B)\n",
    "    # Excess Green Index (vegetation)\n",
    "    ExG = 2 * G - R - B\n",
    "    # Excess Red Index\n",
    "    ExR = 1.4 * R - G\n",
    "    # Green-Red Vegetation Index\n",
    "    GRVI = (G - R) / (G + R)\n",
    "    # Visible Atmospherically Resistant Index\n",
    "    VARI = (G - R) / (G + R - B + 1e-6)\n",
    "    # Normalized Green-Blue Difference\n",
    "    NGBDI = (G - B) / (G + B + 1e-6)\n",
    "    \n",
    "    for idx in [green_ratio, ExG, ExR, GRVI, VARI, NGBDI]:\n",
    "        features.extend([idx.mean(), idx.std(), np.percentile(idx, 75)])\n",
    "    \n",
    "    # === EDA INSIGHT 3: Spatial features for grazing patterns (20 features) ===\n",
    "    mid = w // 2\n",
    "    left = img_rgb[:, :mid]\n",
    "    right = img_rgb[:, mid:]\n",
    "    \n",
    "    # Left vs Right (grazing asymmetry) - 6 features\n",
    "    for channel in range(3):\n",
    "        features.extend([\n",
    "            left[:, :, channel].mean() - right[:, :, channel].mean(),\n",
    "            left[:, :, channel].std() - right[:, :, channel].std()\n",
    "        ])\n",
    "    \n",
    "    # Focus on green channel spatial - 3 features\n",
    "    features.extend([\n",
    "        left[:, :, 1].mean(),\n",
    "        right[:, :, 1].mean(),\n",
    "        abs(left[:, :, 1].mean() - right[:, :, 1].mean())\n",
    "    ])\n",
    "    \n",
    "    # Quadrants (pasture distribution) - 8 features\n",
    "    h_mid = h // 2\n",
    "    quads = [\n",
    "        img_rgb[:h_mid, :mid],\n",
    "        img_rgb[:h_mid, mid:],\n",
    "        img_rgb[h_mid:, :mid],\n",
    "        img_rgb[h_mid:, mid:]\n",
    "    ]\n",
    "    \n",
    "    for quad in quads:\n",
    "        features.extend([\n",
    "            quad[:, :, 1].mean(),  # Green mean\n",
    "            quad[:, :, 1].std()    # Green variance\n",
    "        ])\n",
    "    \n",
    "    # Vertical profile (growth patterns) - 2 features\n",
    "    features.append(img_rgb[:h//3, :, 1].mean())\n",
    "    features.append(img_rgb[2*h//3:, :, 1].mean())\n",
    "    \n",
    "    # === Texture Features (18 features) ===\n",
    "    edges = cv2.Canny(img_gray, 50, 150)\n",
    "    features.extend([\n",
    "        edges.mean(), edges.std(),\n",
    "        np.count_nonzero(edges) / edges.size\n",
    "    ])\n",
    "    \n",
    "    sobelx = cv2.Sobel(img_gray, cv2.CV_64F, 1, 0, ksize=3)\n",
    "    sobely = cv2.Sobel(img_gray, cv2.CV_64F, 0, 1, ksize=3)\n",
    "    gradient = np.sqrt(sobelx**2 + sobely**2)\n",
    "    features.extend([\n",
    "        gradient.mean(), gradient.std(),\n",
    "        np.percentile(gradient, 90)\n",
    "    ])\n",
    "    \n",
    "    laplacian = cv2.Laplacian(img_gray, cv2.CV_64F)\n",
    "    features.extend([\n",
    "        laplacian.mean(), laplacian.std(),\n",
    "        np.abs(laplacian).mean()\n",
    "    ])\n",
    "    \n",
    "    features.extend([\n",
    "        img_gray.mean(), img_gray.std(),\n",
    "        np.percentile(img_gray, 25), np.percentile(img_gray, 75),\n",
    "        img_gray.max(), img_gray.min()\n",
    "    ])\n",
    "    \n",
    "    # Additional texture - 3 features\n",
    "    features.extend([\n",
    "        cv2.Laplacian(green, cv2.CV_64F).var(),  # Green texture\n",
    "        np.percentile(edges, 95),\n",
    "        (edges > 0).sum() / edges.size\n",
    "    ])\n",
    "    \n",
    "    # === Saturation & Brightness (12 features) ===\n",
    "    saturation = img_hsv[:, :, 1]\n",
    "    value = img_hsv[:, :, 2]\n",
    "    \n",
    "    features.extend([\n",
    "        saturation.mean(), saturation.std(),\n",
    "        np.percentile(saturation, 25), np.percentile(saturation, 75),\n",
    "        (saturation > 50).mean(), (saturation > 100).mean()\n",
    "    ])\n",
    "    \n",
    "    features.extend([\n",
    "        value.mean(), value.std(),\n",
    "        np.percentile(value, 25), np.percentile(value, 75),\n",
    "        (value > 128).mean(), (value < 50).mean()\n",
    "    ])\n",
    "    \n",
    "    # === Additional Color Features (9 features) ===\n",
    "    # Color ratios\n",
    "    features.extend([\n",
    "        (R / (G + 1e-6)).mean(),\n",
    "        (B / (G + 1e-6)).mean(),\n",
    "        (R / (B + 1e-6)).mean()\n",
    "    ])\n",
    "    \n",
    "    # Color differences\n",
    "    features.extend([\n",
    "        (G - R).mean(),\n",
    "        (G - B).mean(),\n",
    "        (R - B).mean()\n",
    "    ])\n",
    "    \n",
    "    # Advanced indices\n",
    "    features.extend([\n",
    "        ((G - R) / (G + R + 1e-6)).mean(),  # NGRDI\n",
    "        ((G - B) / (G + B + 1e-6)).mean(),  # NGBDI alt\n",
    "        (2 * G - R - B).std()  # ExG variance\n",
    "    ])\n",
    "    \n",
    "    feature_array = np.array(features)\n",
    "    \n",
    "    # Ensure exactly 150 features\n",
    "    if len(feature_array) != 150:\n",
    "        print(f\"Warning: Got {len(feature_array)} features, expected 150. Padding/truncating.\")\n",
    "        if len(feature_array) < 150:\n",
    "            feature_array = np.pad(feature_array, (0, 150 - len(feature_array)), mode='constant')\n",
    "        else:\n",
    "            feature_array = feature_array[:150]\n",
    "    \n",
    "    return feature_array\n",
    "\n",
    "def load_or_create_features(df, image_dir, feature_cache_path=None):\n",
    "    \"\"\"Load or create EDA-informed features\"\"\"\n",
    "    if feature_cache_path and os.path.exists(feature_cache_path):\n",
    "        print(f\"Loading cached features from {feature_cache_path}\")\n",
    "        return pd.read_parquet(feature_cache_path)\n",
    "    \n",
    "    print(\"Extracting EDA-informed features (150 features)...\")\n",
    "    features_list = []\n",
    "    image_paths = []\n",
    "    \n",
    "    for idx in tqdm(range(len(df)), desc=\"Processing images\"):\n",
    "        row = df.iloc[idx]\n",
    "        img_path_value = row['image_path']\n",
    "        img_name = os.path.basename(str(img_path_value))\n",
    "        img_path = image_dir / img_name\n",
    "        \n",
    "        try:\n",
    "            features = extract_eda_features(img_path)\n",
    "        except Exception as e:\n",
    "            print(f\"Error processing {img_path}: {e}\")\n",
    "            features = np.zeros(150)\n",
    "        \n",
    "        features_list.append(features)\n",
    "        image_paths.append(img_path_value)\n",
    "    \n",
    "    feature_cols = [f'feat_{i}' for i in range(150)]\n",
    "    feature_df = pd.DataFrame(features_list, columns=feature_cols)\n",
    "    feature_df['image_path'] = image_paths\n",
    "    \n",
    "    for col in cfg.TARGET_COLS:\n",
    "        if col in df.columns:\n",
    "            feature_df[col] = df[col].values\n",
    "    \n",
    "    if feature_cache_path:\n",
    "        feature_df.to_parquet(feature_cache_path, index=False)\n",
    "        print(f\"Cached features to {feature_cache_path}\")\n",
    "    \n",
    "    return feature_df\n",
    "\n",
    "# ================================================================\n",
    "# EDA-Informed Model\n",
    "# ================================================================\n",
    "\n",
    "def create_eda_model(target_name):\n",
    "    \"\"\"\n",
    "    EDA Finding: Total Biomass is 50% of score\n",
    "    Use stronger ensemble\n",
    "    \"\"\"\n",
    "    \n",
    "    # Stronger models for Total Biomass (50% weight!)\n",
    "    is_total = target_name == 'Dry_Total_g'\n",
    "    \n",
    "    lgb = LGBMRegressor(\n",
    "        n_estimators=600 if is_total else 500,\n",
    "        learning_rate=0.025 if is_total else 0.03,\n",
    "        max_depth=9 if is_total else 8,\n",
    "        num_leaves=150 if is_total else 100,\n",
    "        min_child_samples=10 if is_total else 15,\n",
    "        subsample=0.85,\n",
    "        colsample_bytree=0.85,\n",
    "        reg_alpha=0.1,\n",
    "        reg_lambda=0.1,\n",
    "        random_state=cfg.SEED,\n",
    "        verbose=-1,\n",
    "        n_jobs=-1\n",
    "    )\n",
    "    \n",
    "    xgb = XGBRegressor(\n",
    "        n_estimators=600 if is_total else 500,\n",
    "        learning_rate=0.025 if is_total else 0.03,\n",
    "        max_depth=9 if is_total else 8,\n",
    "        min_child_weight=2,\n",
    "        subsample=0.85,\n",
    "        colsample_bytree=0.85,\n",
    "        reg_alpha=0.1,\n",
    "        reg_lambda=0.1,\n",
    "        random_state=cfg.SEED,\n",
    "        n_jobs=-1,\n",
    "        tree_method='hist'\n",
    "    )\n",
    "    \n",
    "    cat = CatBoostRegressor(\n",
    "        iterations=600 if is_total else 500,\n",
    "        learning_rate=0.025 if is_total else 0.03,\n",
    "        depth=8 if is_total else 7,\n",
    "        l2_leaf_reg=3,\n",
    "        random_state=cfg.SEED,\n",
    "        verbose=0,\n",
    "        thread_count=-1\n",
    "    )\n",
    "    \n",
    "    model = VotingRegressor([\n",
    "        ('lgb', lgb),\n",
    "        ('xgb', xgb),\n",
    "        ('cat', cat)\n",
    "    ])\n",
    "    \n",
    "    return model\n",
    "\n",
    "def train_eda_model(train_df, feature_cols):\n",
    "    \"\"\"Train EDA-informed model with log transformation\"\"\"\n",
    "    \n",
    "    set_seed(cfg.SEED)\n",
    "    kfold = KFold(n_splits=cfg.N_FOLDS, shuffle=True, random_state=cfg.SEED)\n",
    "    \n",
    "    X_df = train_df[feature_cols].copy()\n",
    "    \n",
    "    # EDA Finding: Data is right-skewed - use power transform\n",
    "    scaler = RobustScaler()\n",
    "    X_scaled = pd.DataFrame(\n",
    "        scaler.fit_transform(X_df),\n",
    "        columns=X_df.columns,\n",
    "        index=X_df.index\n",
    "    )\n",
    "    \n",
    "    # Apply power transform for skewed data\n",
    "    pt = PowerTransformer(method='yeo-johnson')\n",
    "    X_transformed = pd.DataFrame(\n",
    "        pt.fit_transform(X_scaled),\n",
    "        columns=X_df.columns,\n",
    "        index=X_df.index\n",
    "    )\n",
    "    \n",
    "    # PCA 98%\n",
    "    pca = PCA(n_components=0.98, random_state=cfg.SEED)\n",
    "    X_pca_array = pca.fit_transform(X_transformed)\n",
    "    pca_cols = [f'pca_{i}' for i in range(X_pca_array.shape[1])]\n",
    "    X_pca = pd.DataFrame(X_pca_array, columns=pca_cols, index=X_df.index)\n",
    "    \n",
    "    print(f\"Features: {len(feature_cols)} -> PCA: {len(pca_cols)}\")\n",
    "    \n",
    "    oof_predictions = np.zeros((len(train_df), len(cfg.TARGET_COLS)))\n",
    "    models = []\n",
    "    \n",
    "    for fold, (train_idx, val_idx) in enumerate(kfold.split(train_df)):\n",
    "        print(f\"\\n{'='*60}\")\n",
    "        print(f\"Fold {fold + 1}/{cfg.N_FOLDS}\")\n",
    "        print(f\"{'='*60}\")\n",
    "        \n",
    "        X_train = X_pca.iloc[train_idx]\n",
    "        X_val = X_pca.iloc[val_idx]\n",
    "        \n",
    "        fold_models = []\n",
    "        \n",
    "        for target_idx, target_col in enumerate(cfg.TARGET_COLS):\n",
    "            y_train = train_df.iloc[train_idx][target_col].values\n",
    "            y_val = train_df.iloc[val_idx][target_col].values\n",
    "            \n",
    "            # Create model (stronger for Total)\n",
    "            model = create_eda_model(target_col)\n",
    "            model.fit(X_train, y_train)\n",
    "            \n",
    "            # Predict\n",
    "            pred = model.predict(X_val)\n",
    "            pred = np.clip(pred, 0, None)\n",
    "            \n",
    "            oof_predictions[val_idx, target_idx] = pred\n",
    "            fold_models.append(model)\n",
    "            \n",
    "            # R²\n",
    "            ss_res = ((y_val - pred) ** 2).mean()\n",
    "            ss_tot = ((y_val - y_val.mean()) ** 2).mean()\n",
    "            r2 = 1 - ss_res / ss_tot\n",
    "            \n",
    "            # Mark if this is the important target\n",
    "            marker = \" ⭐ (50% weight!)\" if target_col == 'Dry_Total_g' else \"\"\n",
    "            print(f\"  {target_col}: R² = {r2:.4f}{marker}\")\n",
    "        \n",
    "        models.append(fold_models)\n",
    "        \n",
    "        fold_score = competition_metric(\n",
    "            train_df.iloc[val_idx][cfg.TARGET_COLS].values,\n",
    "            oof_predictions[val_idx]\n",
    "        )\n",
    "        print(f\"\\nFold {fold + 1} Score: {fold_score:.4f}\")\n",
    "    \n",
    "    cv_score = competition_metric(\n",
    "        train_df[cfg.TARGET_COLS].values,\n",
    "        oof_predictions\n",
    "    )\n",
    "    \n",
    "    print(f\"\\n{'='*60}\")\n",
    "    print(f\"Overall CV Score: {cv_score:.4f}\")\n",
    "    print(f\"{'='*60}\")\n",
    "    \n",
    "    return models, scaler, pt, pca, pca_cols, oof_predictions\n",
    "\n",
    "# ================================================================\n",
    "# Inference\n",
    "# ================================================================\n",
    "\n",
    "def predict_eda(test_df, models, scaler, pt, pca, pca_cols, feature_cols):\n",
    "    \"\"\"EDA-informed prediction\"\"\"\n",
    "    \n",
    "    print(\"\\nGenerating predictions...\")\n",
    "    \n",
    "    X_test_df = test_df[feature_cols].copy()\n",
    "    \n",
    "    X_test_scaled = pd.DataFrame(\n",
    "        scaler.transform(X_test_df),\n",
    "        columns=X_test_df.columns,\n",
    "        index=X_test_df.index\n",
    "    )\n",
    "    \n",
    "    X_test_transformed = pd.DataFrame(\n",
    "        pt.transform(X_test_scaled),\n",
    "        columns=X_test_df.columns,\n",
    "        index=X_test_df.index\n",
    "    )\n",
    "    \n",
    "    X_test_pca = pd.DataFrame(\n",
    "        pca.transform(X_test_transformed),\n",
    "        columns=pca_cols,\n",
    "        index=X_test_df.index\n",
    "    )\n",
    "    \n",
    "    predictions = np.zeros((len(test_df), len(cfg.TARGET_COLS)))\n",
    "    \n",
    "    for fold_idx, fold_models in enumerate(models):\n",
    "        for target_idx, model in enumerate(fold_models):\n",
    "            pred = model.predict(X_test_pca)\n",
    "            pred = np.clip(pred, 0, None)\n",
    "            predictions[:, target_idx] += pred\n",
    "    \n",
    "    predictions /= len(models)\n",
    "    \n",
    "    return predictions\n",
    "\n",
    "# ================================================================\n",
    "# Main Execution\n",
    "# ================================================================\n",
    "\n",
    "def main():\n",
    "    print(\"=\"*60)\n",
    "    print(\"CSIRO BIOMASS - EDA-INFORMED VERSION (FIXED)\")\n",
    "    print(\"All recommendations implemented!\")\n",
    "    print(\"=\"*60)\n",
    "    \n",
    "    set_seed(cfg.SEED)\n",
    "    \n",
    "    # Load\n",
    "    print(\"\\n1. Loading data...\")\n",
    "    train_df = pd.read_csv(cfg.BASE_PATH / \"train.csv\")\n",
    "    test_df = pd.read_csv(cfg.BASE_PATH / \"test.csv\")\n",
    "    \n",
    "    # Pivot\n",
    "    print(\"\\n2. Pivoting data...\")\n",
    "    train_pivot = train_df.pivot_table(\n",
    "        values='target',\n",
    "        index='image_path',\n",
    "        columns='target_name',\n",
    "        aggfunc='mean'\n",
    "    ).reset_index()\n",
    "    \n",
    "    for col in cfg.TARGET_COLS:\n",
    "        if col in train_pivot.columns:\n",
    "            train_pivot[col] = pd.to_numeric(train_pivot[col], errors='coerce').fillna(0.0)\n",
    "    \n",
    "    train_pivot['image_path'] = train_pivot['image_path'].apply(\n",
    "        lambda x: os.path.basename(x) if isinstance(x, str) else x\n",
    "    )\n",
    "    \n",
    "    test_unique = test_df.drop_duplicates('image_path').reset_index(drop=True)\n",
    "    test_unique['image_path'] = test_unique['image_path'].apply(\n",
    "        lambda x: os.path.basename(x) if isinstance(x, str) else x\n",
    "    )\n",
    "    \n",
    "    # Features\n",
    "    print(\"\\n3. Extracting EDA-informed features...\")\n",
    "    train_features = load_or_create_features(\n",
    "        train_pivot,\n",
    "        cfg.TRAIN_PATH,\n",
    "        feature_cache_path='/kaggle/working/train_features_eda.parquet'\n",
    "    )\n",
    "    \n",
    "    test_features = load_or_create_features(\n",
    "        test_unique,\n",
    "        cfg.TEST_PATH,\n",
    "        feature_cache_path='/kaggle/working/test_features_eda.parquet'\n",
    "    )\n",
    "    \n",
    "    feature_cols = [col for col in train_features.columns if col.startswith('feat_')]\n",
    "    print(f\"Features: {len(feature_cols)}\")\n",
    "    \n",
    "    # Train\n",
    "    print(\"\\n4. Training EDA-informed model...\")\n",
    "    models, scaler, pt, pca, pca_cols, oof_preds = train_eda_model(train_features, feature_cols)\n",
    "    \n",
    "    # Reconcile (EDA recommendation!)\n",
    "    print(\"\\n5. Applying hierarchical reconciliation...\")\n",
    "    oof_df = pd.DataFrame(oof_preds, columns=cfg.TARGET_COLS)\n",
    "    oof_reconciled = reconcile_predictions(oof_df)\n",
    "    \n",
    "    reconciled_score = competition_metric(\n",
    "        train_features[cfg.TARGET_COLS].values,\n",
    "        oof_reconciled.values\n",
    "    )\n",
    "    print(f\"Reconciled CV Score: {reconciled_score:.4f}\")\n",
    "    \n",
    "    # Predict\n",
    "    print(\"\\n6. Predicting on test...\")\n",
    "    test_preds = predict_eda(test_features, models, scaler, pt, pca, pca_cols, feature_cols)\n",
    "    \n",
    "    # Submission\n",
    "    print(\"\\n7. Creating submission...\")\n",
    "    pred_df = pd.DataFrame(test_preds, columns=cfg.TARGET_COLS)\n",
    "    pred_df['image_path'] = test_features['image_path'].values\n",
    "    pred_df = reconcile_predictions(pred_df)\n",
    "    \n",
    "    pred_long = pred_df.melt(\n",
    "        id_vars='image_path',\n",
    "        value_vars=cfg.TARGET_COLS,\n",
    "        var_name='target_name',\n",
    "        value_name='target'\n",
    "    )\n",
    "    \n",
    "    test_df['image_path_basename'] = test_df['image_path'].apply(\n",
    "        lambda x: os.path.basename(x) if isinstance(x, str) else x\n",
    "    )\n",
    "    pred_long['image_path_basename'] = pred_long['image_path'].apply(\n",
    "        lambda x: os.path.basename(x) if isinstance(x, str) else x\n",
    "    )\n",
    "    \n",
    "    submission = test_df[['sample_id', 'image_path_basename', 'target_name']].merge(\n",
    "        pred_long[['image_path_basename', 'target_name', 'target']],\n",
    "        on=['image_path_basename', 'target_name'],\n",
    "        how='left'\n",
    "    )[['sample_id', 'target']]\n",
    "    \n",
    "    submission.to_csv('/kaggle/working/submission.csv', index=False)\n",
    "    \n",
    "    print(\"\\n\" + \"=\"*60)\n",
    "    print(\"✓ EDA-INFORMED VERSION COMPLETE!\")\n",
    "    print(\"=\"*60)\n",
    "    print(f\"\\nFinal CV Score: {reconciled_score:.4f}\")\n",
    "    print(\"\\nAll EDA Recommendations Applied:\")\n",
    "    print(\"  ✓ Green channel emphasized (20 features)\")\n",
    "    print(\"  ✓ Vegetation indices (6 types)\")\n",
    "    print(\"  ✓ Spatial features (grazing patterns)\")\n",
    "    print(\"  ✓ PowerTransform for skewness\")\n",
    "    print(\"  ✓ Stronger model for Total (50% weight)\")\n",
    "    print(\"  ✓ Hierarchical reconciliation\")\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  }
 ],
 "metadata": {
  "kaggle": {
   "accelerator": "gpu",
   "dataSources": [
    {
     "databundleVersionId": 14254895,
     "sourceId": 112509,
     "sourceType": "competition"
    },
    {
     "datasetId": 8856212,
     "isSourceIdPinned": false,
     "sourceId": 13900620,
     "sourceType": "datasetVersion"
    },
    {
     "datasetId": 8929818,
     "isSourceIdPinned": false,
     "sourceId": 14018229,
     "sourceType": "datasetVersion"
    },
    {
     "sourceId": 288467413,
     "sourceType": "kernelVersion"
    },
    {
     "sourceId": 288631580,
     "sourceType": "kernelVersion"
    },
    {
     "modelId": 986,
     "modelInstanceId": 3329,
     "sourceId": 4537,
     "sourceType": "modelInstanceVersion"
    },
    {
     "modelId": 251887,
     "modelInstanceId": 230141,
     "sourceId": 268942,
     "sourceType": "modelInstanceVersion"
    },
    {
     "modelId": 487624,
     "modelInstanceId": 471723,
     "sourceId": 663314,
     "sourceType": "modelInstanceVersion"
    }
   ],
   "dockerImageVersionId": 31234,
   "isGpuEnabled": true,
   "isInternetEnabled": false,
   "language": "python",
   "sourceType": "notebook"
  },
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.12"
  },
  "papermill": {
   "default_parameters": {},
   "duration": 849.739595,
   "end_time": "2025-12-27T04:17:33.289079",
   "environment_variables": {},
   "exception": null,
   "input_path": "__notebook__.ipynb",
   "output_path": "__notebook__.ipynb",
   "parameters": {},
   "start_time": "2025-12-27T04:03:23.549484",
   "version": "2.6.0"
  },
  "widgets": {
   "application/vnd.jupyter.widget-state+json": {
    "state": {
     "0318792581244540b44b60dce3e5981a": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HBoxModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HBoxModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "HBoxView",
       "box_style": "",
       "children": [
        "IPY_MODEL_df23045d1f1c4f3fa4782f1ba611f7b1",
        "IPY_MODEL_5ef573ed16c44ff781790f788bb9d035",
        "IPY_MODEL_f552d0ea98e54c2cae693b6f3a9e7b5c"
       ],
       "layout": "IPY_MODEL_92bc1098b4e5490a8f007cf3a9434d09",
       "tabbable": null,
       "tooltip": null
      }
     },
     "03daf86415c64768915c6c10a7906ff8": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "09e759dc11764d27903c2ddb15b621ac": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HTMLStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HTMLStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "StyleView",
       "background": null,
       "description_width": "",
       "font_size": null,
       "text_color": null
      }
     },
     "0a0c511b433244a68bf5bf68f6da9a4e": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "FloatProgressModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "FloatProgressModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "ProgressView",
       "bar_style": "success",
       "description": "",
       "description_allow_html": false,
       "layout": "IPY_MODEL_3b176df8256b4f20ad7b034bfa2d400e",
       "max": 1.0,
       "min": 0.0,
       "orientation": "horizontal",
       "style": "IPY_MODEL_f6d3bdc3a1794e26b21f055d30507885",
       "tabbable": null,
       "tooltip": null,
       "value": 1.0
      }
     },
     "1400faa0c1844a8688e7442a477e7426": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HTMLStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HTMLStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "StyleView",
       "background": null,
       "description_width": "",
       "font_size": null,
       "text_color": null
      }
     },
     "166625014fa04be3930929dbdbecbec6": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HBoxModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HBoxModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "HBoxView",
       "box_style": "",
       "children": [
        "IPY_MODEL_adc1ce04c040408eb396abe94cf622bb",
        "IPY_MODEL_0a0c511b433244a68bf5bf68f6da9a4e",
        "IPY_MODEL_aaee651064b5443aba1f3b5cc764239c"
       ],
       "layout": "IPY_MODEL_27372facef0c4c109bf4c2d0239fa234",
       "tabbable": null,
       "tooltip": null
      }
     },
     "27372facef0c4c109bf4c2d0239fa234": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "2937140f7d05466fad7d5e85c8d03f0b": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "FloatProgressModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "FloatProgressModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "ProgressView",
       "bar_style": "success",
       "description": "",
       "description_allow_html": false,
       "layout": "IPY_MODEL_694e635a37a1427da741ae0805357c0e",
       "max": 357.0,
       "min": 0.0,
       "orientation": "horizontal",
       "style": "IPY_MODEL_adedd0d6095b47e698fb9ec2ddbac0f7",
       "tabbable": null,
       "tooltip": null,
       "value": 357.0
      }
     },
     "3322c3d96fd9486ba0207fa5a6eb0150": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "3a6181dc32c14e0088af68e3dfa0a55e": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "3b176df8256b4f20ad7b034bfa2d400e": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "5a3aec14239540fa94c10cffead938dd": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HTMLStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HTMLStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "StyleView",
       "background": null,
       "description_width": "",
       "font_size": null,
       "text_color": null
      }
     },
     "5c42e9c4d8f34873887f88fb5264b89b": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HTMLStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HTMLStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "StyleView",
       "background": null,
       "description_width": "",
       "font_size": null,
       "text_color": null
      }
     },
     "5e3d7e04d4be414496a3fee2e124db46": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HTMLModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HTMLModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "HTMLView",
       "description": "",
       "description_allow_html": false,
       "layout": "IPY_MODEL_e1fb6337d80c451cbcf54239cfdfd5cc",
       "placeholder": "​",
       "style": "IPY_MODEL_d2db06b9db08422cadbfc5270d3de9a9",
       "tabbable": null,
       "tooltip": null,
       "value": " 357/357 [02:49&lt;00:00,  2.16it/s]"
      }
     },
     "5ef573ed16c44ff781790f788bb9d035": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "FloatProgressModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "FloatProgressModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "ProgressView",
       "bar_style": "success",
       "description": "",
       "description_allow_html": false,
       "layout": "IPY_MODEL_7273971c02f44b2dbfd58d60222086a4",
       "max": 1.0,
       "min": 0.0,
       "orientation": "horizontal",
       "style": "IPY_MODEL_d1142dbce3954acf95bf0229e6621136",
       "tabbable": null,
       "tooltip": null,
       "value": 1.0
      }
     },
     "694e635a37a1427da741ae0805357c0e": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "7076350fff4241149a907a4513461958": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HTMLStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HTMLStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "StyleView",
       "background": null,
       "description_width": "",
       "font_size": null,
       "text_color": null
      }
     },
     "7273971c02f44b2dbfd58d60222086a4": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "741a832efe7c4cf59d9a2733dbf40e7e": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "8d4ec5a11f674c26a708d66edde63cb2": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "8eab96167e25428b93e05e9797f959ff": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "ProgressStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "ProgressStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "StyleView",
       "bar_color": null,
       "description_width": ""
      }
     },
     "92bc1098b4e5490a8f007cf3a9434d09": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "931e24df19a7444995b7308cc9780152": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "a8bd7f264b05434cb715076b603c9a56": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "FloatProgressModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "FloatProgressModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "ProgressView",
       "bar_style": "success",
       "description": "",
       "description_allow_html": false,
       "layout": "IPY_MODEL_931e24df19a7444995b7308cc9780152",
       "max": 357.0,
       "min": 0.0,
       "orientation": "horizontal",
       "style": "IPY_MODEL_8eab96167e25428b93e05e9797f959ff",
       "tabbable": null,
       "tooltip": null,
       "value": 357.0
      }
     },
     "aaee651064b5443aba1f3b5cc764239c": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HTMLModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HTMLModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "HTMLView",
       "description": "",
       "description_allow_html": false,
       "layout": "IPY_MODEL_3322c3d96fd9486ba0207fa5a6eb0150",
       "placeholder": "​",
       "style": "IPY_MODEL_5a3aec14239540fa94c10cffead938dd",
       "tabbable": null,
       "tooltip": null,
       "value": " 1/1 [00:01&lt;00:00,  1.29s/it]"
      }
     },
     "adc1ce04c040408eb396abe94cf622bb": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HTMLModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HTMLModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "HTMLView",
       "description": "",
       "description_allow_html": false,
       "layout": "IPY_MODEL_d74302bfe76f457e9dbde98f8f56d7f1",
       "placeholder": "​",
       "style": "IPY_MODEL_e5481f4644aa4c57bc16d5af9fc5dd5c",
       "tabbable": null,
       "tooltip": null,
       "value": "Processing images: 100%"
      }
     },
     "adedd0d6095b47e698fb9ec2ddbac0f7": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "ProgressStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "ProgressStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "StyleView",
       "bar_color": null,
       "description_width": ""
      }
     },
     "cf59e0074da24091940dd6f2cff1bcb7": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "d06a8e1dd9a449518943911373342f32": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HTMLModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HTMLModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "HTMLView",
       "description": "",
       "description_allow_html": false,
       "layout": "IPY_MODEL_741a832efe7c4cf59d9a2733dbf40e7e",
       "placeholder": "​",
       "style": "IPY_MODEL_5c42e9c4d8f34873887f88fb5264b89b",
       "tabbable": null,
       "tooltip": null,
       "value": "Processing images: 100%"
      }
     },
     "d1142dbce3954acf95bf0229e6621136": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "ProgressStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "ProgressStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "StyleView",
       "bar_color": null,
       "description_width": ""
      }
     },
     "d1e9ab9b066345f1abcca961b1f4623d": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HBoxModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HBoxModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "HBoxView",
       "box_style": "",
       "children": [
        "IPY_MODEL_d06a8e1dd9a449518943911373342f32",
        "IPY_MODEL_a8bd7f264b05434cb715076b603c9a56",
        "IPY_MODEL_5e3d7e04d4be414496a3fee2e124db46"
       ],
       "layout": "IPY_MODEL_3a6181dc32c14e0088af68e3dfa0a55e",
       "tabbable": null,
       "tooltip": null
      }
     },
     "d2db06b9db08422cadbfc5270d3de9a9": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HTMLStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HTMLStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "StyleView",
       "background": null,
       "description_width": "",
       "font_size": null,
       "text_color": null
      }
     },
     "d74302bfe76f457e9dbde98f8f56d7f1": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "da54e685eaba415da997a61de166c1ec": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HTMLModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HTMLModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "HTMLView",
       "description": "",
       "description_allow_html": false,
       "layout": "IPY_MODEL_8d4ec5a11f674c26a708d66edde63cb2",
       "placeholder": "​",
       "style": "IPY_MODEL_09e759dc11764d27903c2ddb15b621ac",
       "tabbable": null,
       "tooltip": null,
       "value": " 357/357 [07:18&lt;00:00,  1.20s/it]"
      }
     },
     "df23045d1f1c4f3fa4782f1ba611f7b1": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HTMLModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HTMLModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "HTMLView",
       "description": "",
       "description_allow_html": false,
       "layout": "IPY_MODEL_03daf86415c64768915c6c10a7906ff8",
       "placeholder": "​",
       "style": "IPY_MODEL_7076350fff4241149a907a4513461958",
       "tabbable": null,
       "tooltip": null,
       "value": "Processing images: 100%"
      }
     },
     "e089b284447f4073a999b1ceffe47cbf": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HTMLStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HTMLStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "StyleView",
       "background": null,
       "description_width": "",
       "font_size": null,
       "text_color": null
      }
     },
     "e1fb6337d80c451cbcf54239cfdfd5cc": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "e2fbaf889edc485d8ec6d7b29d3e93f0": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HTMLModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HTMLModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "HTMLView",
       "description": "",
       "description_allow_html": false,
       "layout": "IPY_MODEL_cf59e0074da24091940dd6f2cff1bcb7",
       "placeholder": "​",
       "style": "IPY_MODEL_e089b284447f4073a999b1ceffe47cbf",
       "tabbable": null,
       "tooltip": null,
       "value": "Processing images: 100%"
      }
     },
     "e5481f4644aa4c57bc16d5af9fc5dd5c": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HTMLStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HTMLStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "StyleView",
       "background": null,
       "description_width": "",
       "font_size": null,
       "text_color": null
      }
     },
     "f552d0ea98e54c2cae693b6f3a9e7b5c": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HTMLModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HTMLModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "HTMLView",
       "description": "",
       "description_allow_html": false,
       "layout": "IPY_MODEL_fb2d32bf547c42259e15e723fe246331",
       "placeholder": "​",
       "style": "IPY_MODEL_1400faa0c1844a8688e7442a477e7426",
       "tabbable": null,
       "tooltip": null,
       "value": " 1/1 [00:00&lt;00:00,  2.07it/s]"
      }
     },
     "f6d3bdc3a1794e26b21f055d30507885": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "ProgressStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "ProgressStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "StyleView",
       "bar_color": null,
       "description_width": ""
      }
     },
     "fb2d32bf547c42259e15e723fe246331": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "ff4525395a2d4bb8bf489a74246db94c": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "ffd0467f6f2545bfbe9be0b03cb2c65b": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HBoxModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HBoxModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "HBoxView",
       "box_style": "",
       "children": [
        "IPY_MODEL_e2fbaf889edc485d8ec6d7b29d3e93f0",
        "IPY_MODEL_2937140f7d05466fad7d5e85c8d03f0b",
        "IPY_MODEL_da54e685eaba415da997a61de166c1ec"
       ],
       "layout": "IPY_MODEL_ff4525395a2d4bb8bf489a74246db94c",
       "tabbable": null,
       "tooltip": null
      }
     }
    },
    "version_major": 2,
    "version_minor": 0
   }
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
